<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Control Flow - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Ngôn ngữ lập trình Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Cài đặt</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html" class="active"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="các-khối-điều-khiển"><a class="header" href="#các-khối-điều-khiển">Các khối điều khiển</a></h2>
<p>Khả năng chạy một số đoạn lệnh dựa trên một điều kiện nào đó, hoặc chạy lặp lại một
lệnh khi một điều kiện nào đó là đúng, là các khối điều khiển cơ bản có trong hầu 
hết các ngôn ngữ lập trình. Khối điều khiển phổ biến nhất cho phép bạn kiểm soát việc
thực thi các đoạn code trong Rust là các biểu thức <code>if</code> và các lệnh lặp.</p>
<h3 id="biểu-thức-if"><a class="header" href="#biểu-thức-if">Biểu thức <code>if</code></a></h3>
<p>Một biểu thức <code>if</code> cho phép bạn rẽ nhánh thực thi dựa trên các điều kiện nào đó.
Bạn cung cấp một điều kiện và phát biểu: &quot;Nếu điều kiện này đúng, hãy chạy đoạn lệnh
này. Nếu không đạt, đừng chạy nó&quot;.</p>
<p>Tạo một dự án mới được gọi là <em>branches</em> trong thư mục <em>projects</em> để khảo sát biểu
thức <code>if</code>. Trong file <em>src/main.rs</em>, hãy nhập vào nội dung sau:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<p>Tất cả các phát biểu <code>if</code> sẽ bắt đầu bằng từ khóa <code>if</code>, theo sau bởi một điều kiện.
Trong trường hợp này, điều kiện là kiểm tra xem liệu biến <code>number</code> có giá trị nhỏ
hơn 5 hay không. Chúng ta đặt khối lệnh để thực thi nếu điều kiện là đúng ngay sau
dấu ngoặc đóng của điều kiện. Các khối lệnh kết hợp với <code>if</code> đôi khi được gọi là 
<em>arm</em>, giống như <em>arms</em> trong phát biểu <code>match</code> mà ta đã thảo luận trong phần 
<a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the Secret Number”</a><!--
ignore --> section of Chapter 2.</p>
<p>Chúng ta cũng có thể tùy chọn thêm một phát biểu <code>else</code>, giống như chúng ta đã
làm ở đây, để cung cấp một đoạn code mà sẽ được thực thi nếu điều kiện trả về
giá trị false. Nếu bạn không cung cấp <code>else</code>, chương trình sẽ chỉ đơn giản bỏ qua
khối lệnh <code>if</code> và tiếp tục thực thi các lệnh tiếp sau đó.</p>
<p>Thử chạy đoạn lệnh này, bạn sẽ thấy kết xuất như sau:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Hãy thử thay đổi <code>number</code> sang một giá trị làm cho điều kiện trả về kết quả false
để xem điều gì xảy ra:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;condition was true&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;condition was false&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Chạy lại chương trình, và xem kết xuất:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>Một điểm quan trọng cần lưu ý là điều kiện trong đoạn code này bắt buộc <em>phải</em> có 
kiểu <code>bool</code>. Nếu điều kiện này không phải là bool, bạn sẽ nhận một lỗi. Ví dụ, thử 
chạy đoạn lệnh sau:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p>Trong trường hợp này biểu thức trong <code>if</code> trả về giá trị <code>3</code>, và Rust phát ra một
lỗi:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>Lỗi này chỉ ra Rust cần một <code>bool</code> nhưng lại nhận được một integer. Không như
các ngôn ngữ như Ruby hay JavaScript, Rust không tự động thử chuyển các giá trị
không phải boolean sang boolean. Nếu bạn muốn đoạn <code>if</code> chỉ chạy khi một số bằng
với <code>0</code>, bạn có thể viết lại như sau:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>Chạy đoạn code này sẽ trả về kết xuất sau: <code>number was something other than zero</code>.</p>
<h4 id="xử-lý-nhiều-điều-kiện-với-else-if"><a class="header" href="#xử-lý-nhiều-điều-kiện-với-else-if">Xử lý nhiều điều kiện với <code>else if</code></a></h4>
<p>Bạn có thể dùng nhiều điều kiện khác nhau bằng cách kết hợp <code>if</code> với <code>else</code> trong
một biểu thức <code>else if</code>. Ví dụ:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>Chương trình này có bốn nhánh có thể thực thi. Sau khi chạy bạn sẽ thấy kết xuất sau:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>Khi chạy chương trình này, nó sẽ kiểm tra lần lượt mỗi biểu thức <code>if</code> và thực
thi thân <code>if</code> đầu tiên mà biểu thức trả về <code>true</code>. Lưu ý rằng tuy 6 chia hết cho 2, 
chúng ta vẫn không thấy câu <code>number is divisible by 2</code> được in ra, cũng như không
thấy câu <code>number is not divisible by 4, 3, or 2</code> trong khối <code>else</code>. Đó là vì Rust 
chỉ thực thi đoạn lệnh trong thân <code>if</code> đầu tiên mà nó thấy trả về true, và một khi
tìm thấy, nó sẽ thậm chí không kiểm tra các biểu thức phía sau.</p>
<p>Sử dụng quá nhiều <code>else if</code> làm cho code của bạn lộn xộn, do vậy nếu bạn có nhiều 
hơn một, bạn có thể sẽ cần refactor code. Chương 6 mô tả một cấu trúc rẽ nhánh mạnh
mẽ trong Rust được gọi là <code>match</code> phù hợp với trường hợp này.</p>
<h4 id="sử-dụng-if-bên-trong-phát-biểu-let"><a class="header" href="#sử-dụng-if-bên-trong-phát-biểu-let">Sử dụng <code>if</code> bên trong phát biểu <code>let</code></a></h4>
<p>Vì <code>if</code> là một biểu thức, vậy nên ta có thể dùng nó bên phải của một phát biểu <code>let</code>
để gán giá trị trả về cho một biến, như trong Listing 3-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {number}&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 3-2: Gán kết quả của một biểu thức <code>if</code> vào một biến</span></p>
<p>Biến <code>number</code> sẽ được gán một giá trị dựa trên kết quả của một biểu thức <code>if</code>. Chạy 
đoạn code sau để xem điều gì xảy ra:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Hãy nhớ là các khối lệnh sẽ được định giá trị bằng với giá trị của biểu thức cuối
cùng bên trong nó, và bản thân các con số cũng là các biểu thức. Trong trường hợp này,
giá trị của toàn bộ biểu thức <code>if</code> phụ thuộc vào nhánh nào được thực thi. Có nghĩa là
các nhánh của <code>if</code> phải có cùng kiểu; trong Listing 3-2, kết quả của cả hai nhánh 
của <code>if</code> đều có kiểu số nguyên <code>i32</code>. Nếu các kiểu không khớp nhau, như trong ví dụ 
dưới đây, chúng ta sẽ nhận về một lỗi.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;The value of number is: {number}&quot;);
}
</code></pre>
<p>Khi chúng ta thử dịch đoạn code này, chúng ta sẽ nhận về một lỗi. Các nhánh <code>if</code>
và <code>else</code> có các kiểu không tương thích, và Rust chỉ ra chính xác vị trí nơi phát 
sinh lỗi trong chương trình:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>Biểu thức trong khối <code>if</code> trả về một giá trị integer, trong khi biểu thức trong khối <code>else</code> 
trả về một string. Điều này không thể hoạt động được vì các biến chỉ có thể có một kiểu
duy nhất, và Rust cần biết kiểu của biến <code>number</code> là gì ngay khi dịch. Việc biết 
kiểu của biến <code>number</code> cho phép trình dịch xác định tính hợp lệ về kiểu bất cứ khi nào
ta truy xuất đến nó. Rust sẽ không thể làm được điều này nếu nó chỉ có thể xác định kiểu
của <code>number</code> vào lúc chạy chương trình; trình dịch có lẽ sẽ phức tạp hơn nhiều cũng như
khó đảm bảo về đoạn code hơn nếu nó phải lưu giữ thông tin về tất cả các kiểu dữ liệu 
<code>giả tưởng</code> cho bất kỳ biến nào.</p>
<h3 id="sử-dụng-vòng-lặp-loops"><a class="header" href="#sử-dụng-vòng-lặp-loops">Sử dụng vòng lặp (loops)</a></h3>
<p>Chúng ta thường xuyên phải thực thi một đoạn code nào đó nhiều lần. Để làm điều này,
Rust cung cấp một số dạng <em>vòng lặp</em>, nó cho phép chạy đến cuối đoạn code bên trong 
thân vòng lặp , sau đó quay trở lại vị trí bắt đầu. Để trải nghiệm thử các vòng lặp,
chúng ta sẽ cùng tạo một dự án mới có tên <em>loops</em>.</p>
<p>Rust có ba dạng lặp: <code>loop</code>, <code>while</code>, và <code>for</code>. Hãy cùng thử qua từng cái.</p>
<h4 id="lặp-lại-một-đoạn-code-sử-dụng-loop"><a class="header" href="#lặp-lại-một-đoạn-code-sử-dụng-loop">Lặp lại một đoạn code sử dụng <code>loop</code></a></h4>
<p>Từ khóa <code>loop</code> sẽ yêu cầu Rust thực thi một đoạn code lặp đi lặp lại cho đến 
khi bạn yêu cầu nó kết thúc.</p>
<p>Để ví dụ, hãy thay đổi file <em>src/main.rs</em> trong thư mục <em>loops</em> của bạn để nó trông
như sau:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>Khi chạy chương trình này, chúng ta sẽ thấy dòng <code>again!</code> được in lên màn hình
liên tục cho đến khi bạn ngừng chạy chương trình. Hầu hết các terminal hỗ trợ 
tổ hợp phím <span class="keystroke">ctrl-c</span> để ngắt một chương trình đang 
bị kẹt trong một vòng lặp. Hãy cùng chạy thử:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>Ký hiệu <code>^C</code> đại diện cho vị trí bạn nhấn <span class="keystroke">ctrl-c
</span>. Bạn có thể nhìn thấy dòng <code>again!</code> được in phía sau <code>^C</code> hoặc không,
phụ thuộc vào nơi đoạn code đang thực thi bên trong vòng lặp khi nó nhận được
tín hiệu ngắt.</p>
<p>May mắn là Rust cũng cung cấp một cách để thoát khỏi vòng lặp bằng code. Bạn có 
thể đặt một từ khóa <code>break</code> bên trong vòng lặp để nói với chương trình khi nào 
cần thoát khỏi vòng lặp. Hãy nhớ lại chúng ta đã làm điều này trong <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">“Quitting 
After a Correct Guess”</a><!-- ignore --> trong 
chương 2 để thoát khỏi chương trình khi người dùng chiến thắng bằng cách đoán đúng
con số.</p>
<p>Chúng ta cũng dùng <code>continue</code> trong trò chơi đoán số, để yêu cầu chương trình bỏ
qua phần còn lại trong thân vòng lặp hiện tại và bắt đầu một vòng lặp mới.</p>
<h4 id="returning-values-from-loops"><a class="header" href="#returning-values-from-loops">Returning Values from Loops</a></h4>
<p>Một trong những lý do dùng <code>loop</code> là để thực thi lại một tác vụ nào đó bạn biết
có thể sẽ thất bại, kiểu như khi kiểm tra xem một thread đã hoàn thành công việc
hay chưa. Bạn cũng cần trả về kết quả của tác vụ đó cho phần còn lại của chương 
trình khi kết thúc vòng lặp. Để làm điểu này bạn có thể thêm giá trị muốn trả về 
sau phát biểu <code>break</code> mà bạn dùng để kết thúc vòng lặp; giá trị đó sẽ được trả 
về ra ngoài vòng lặp và bạn có thể dùng được nó như trong ví dụ dưới đây:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {result}&quot;);
}
</code></pre></pre>
<p>Trước khi lặp, bạn khai báo một biến tên <code>counter</code> và khởi tạo giá trị của nó là
<code>0</code>. Sau đó bạn khai báo tiếp một biến tên là <code>result</code> để lưu lại giá trị trả về 
từ vòng lặp. Cứ mỗi lần lặp ta lại cộng thêm <code>1</code> vào biến <code>counter</code> và kiểm tra 
giá trị của <code>counter</code> với <code>10</code>, khi điểu này xảy ra, ta dùng từ khóa <code>break</code> với
giá trị trả về là <code>counter </code>* 2<code>. Sau vòng lặp, ta dùng một dấu chấm phẩy để kết  thúc phát biểu gán giá trị vào cho </code>result<code>. Cuối cùng, ta in ra giá trị của </code>result`,
trong trường hợp này sẽ là 20.</p>
<h4 id="gán-nhãn-để-phân-biệt-giữa-các-vòng-lặp"><a class="header" href="#gán-nhãn-để-phân-biệt-giữa-các-vòng-lặp">Gán nhãn để phân biệt giữa các vòng lặp</a></h4>
<p>Nếu bạn có nhiều vòng lặp lồng nhau, <code>break</code> và <code>continue</code> được áp dụng cho vòng 
lặp bên trong nhất tại nơi bạn gọi. Bạn cũng có thể đặt <em>nhãn</em> cho một vòng lặp
để sau đó khi gọi <code>break</code> hoặc <code>continue</code>, ta có thể chỉ ra chính xác ta muốn
áp dụng những từ khóa đó cho vòng lặp đã được gán nhãn thay vì vòng lặp trong cùng.
Các nhãn vòng lặp phải bắt đầu với một dấu nháy đơn. Sau đây là một ví dụ về hai
vòng lặp lồng nhau:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {count}&quot;);
}
</code></pre></pre>
<p>Vòng lặp bên ngoài có nhãn <code>'counting_up</code>, và nó sẽ đếm từ 0 đến 2. Vòng lặp bên trong
không có nhãn và đếm ngược từ 10 xuống 9. Phát biểu <code>break</code> đầu tiên không chỉ ra nhãn 
nên chỉ thoát ra khỏi vòng lặp bên trong. Trong khi đó, phát biểu <code>break 'counting_up;</code>
sẽ thoát ra vòng lặp bên ngoài. Đoạn code này sẽ in ra:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="lặp-theo-điều-kiện-với-while"><a class="header" href="#lặp-theo-điều-kiện-với-while">Lặp theo điều kiện với <code>while</code></a></h4>
<p>Một chương trình sẽ thường phải kiểm tra điều kiện bên trong một vòng lặp. Khi điều
kiện là true, tiếp tục vòng lặp. Khi điều kiện không còn là true, chương trình sẽ
gọi <code>break</code> và ngưng vòng lặp. Bạn hoàn toàn có thể làm những điều trên bằng việc
kết hợp <code>loop</code>, <code>if</code>, <code>else</code> và <code>break</code>; bạn có thể thử ngay nếu muốn. Tuy nhiên,
cấu trúc này rất phổ biến, do vậy Rust tạo ra một cấu trúc lặp riêng cho nó, gọi 
vòng lặp <code>while</code>. Trong Listing 3-3, chúng ta sẽ dùng <code>while</code> để lặp chương trình
3 lần, đếm ngược mỗi lần lặp, in ra một thông báo và kết thúc sau khi hoàn thành 
vòng lặp.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{number}!&quot;);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 3-3: Dùng một vòng lặp <code>while</code> để chạy code trong khi một
điều kiện vẫn còn đúng</span></p>
<p>Vòng lặp này cho phép loại bỏ nhiều cấu trúc lồng nhau như khi bạn kết hợp
<code>loop</code>, <code>if</code>, <code>else</code>, và <code>break</code>, giúp code của bạn sáng sủa hơn. Trong khi một
điều kiện vẫn là <code>true</code>, chạy vòng lặp; ngược lại, kết thúc vòng lặp.</p>
<h4 id="lặp-qua-một-tập-hợp-với-for"><a class="header" href="#lặp-qua-một-tập-hợp-với-for">Lặp qua một tập hợp với <code>for</code></a></h4>
<p>Bạn có thể chọn dùng <code>while</code> để duyệt qua các thành phần của một tập hợp, kiểu 
như một mảng. Ví dụ, vòng lặp trong Listing 3-4 in ra các phần tử có trong mảng
<code>a</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index += 1;
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-4: Lặp qua từng phần tử trong một tập hợp sử dụng 
vòng lặp <code>while</code></span></p>
<p>Ở đây, đoạn code đếm qua các phần tử có trong mảng. Nó bắt đầu từ chỉ số <code>0</code>, và 
tiếp tục lặp cho đến khi gặp chỉ số cuối cùng của mảng (là khi <code>index &lt; 5</code> không 
còn trả về true). Chạy đoạn code này sẽ in ra tất cả các phần tử trong mảng:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>Tất cả năm giá trị trong mảng đều được xuất ra cửa sổ chạy chương trình. Mặc dù
<code>index</code> sẽ đạt giá trị <code>5</code> vào một thời điểm nào đó, vòng lặp sẽ ngừng thực thi 
trước khi cố lấy giá trị thứ sáu (không tồn tại) từ mảng.</p>
<p>Tuy nhiên, các tiếp cận này ẩn chứa lỗi; chúng ta có thể làm chương trình về trạng
thái panic nếu giá trị chỉ số hay điều kiện lặp không chính xác. Ví dụ, nếu bạn 
thay đổi định nghĩa mảng <code>a</code> thành một mảng chỉ có bốn phần tử nhưng lại quên thay
đổi điều kiện thành <code>while index &lt; 4</code>, đoạn code sẽ bị lỗi. Và nó cũng chạy chậm
bởi trình dịch phải thêm code để kiểm tra mỗi lần lặp xem chỉ số có nằm trong 
phạm vi hợp lệ hay không.</p>
<p>Như một cách tiếp cận chính xác hơn, bạn có thể dùng một vòng <code>for</code> và thực thi
code cho mỗi phần tử trong tập hợp. Một vòng lặp <code>for</code> sẽ trông như đoạn code 
trong Listing 3-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;the value is: {element}&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-5: Looping through each element of a collection
using a <code>for</code> loop</span></p>
<p>Khi chạy đoạn code này, bạn sẽ thấy cùng kết xuất như trong Listing 3-4. Quan trọng
hơn, giờ độ an toàn của code cao hơn và loại bỏ cơ hội phát sinh bug khi cố truy
cập một phần tử vượt ra ngoài phạm vi của mảng.</p>
<p>Sử dụng vòng <code>for</code>, bạn cũng không cần phải nhớ thay đổi các đoạn code khác nếu bạn thay
đổi số giá trị có trong mảng, như cách bạn cần làm nếu sử dụng cách thức trong 
Listing 3-4.</p>
<p>Sự an toàn và chính xác của các vòng <code>for</code> làm cho chúng trở thành cấu trúc lặp
phổ biến nhất trong Rust. Ngay cả khi bạn muốn chạy một số code một số lần nhất
định, giống trong ví dụ đếm ngược mà chúng ta dùng vòng lặp <code>while</code>trong Listing 3-3,
hầu hết Rustaceans sẽ chọn dùng <code>for</code>. Để làm điều này ta có thể dùng một <code>Range</code>,
vốn được cung cấp bởi thư viện chuẩn, và sẽ tạo ra tất cả các con số tuần tự bắt 
đầu từ một giá trị và kết thúc trước một giá trị khác.</p>
<p>Đây là ví dụ countdown được viết lại dùng vòng <code>for</code> và một phương thức khác ta chưa 
nhắc đến, <code>rev</code>, để đảo ngược <code>Range</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{number}!&quot;);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>Đoạn code này trông rõ ràng sáng sủa hơn phải không?</p>
<h2 id="tổng-kết"><a class="header" href="#tổng-kết">Tổng kết</a></h2>
<p>Bạn đã làm được! Đây thật là một chương với rất nhiều thông tin: bạn học về biến,
các kiểu dữ liệu vô hướng và kết hợp, hàm, ghi chú, phát biểu <code>if</code>, và cả các
vòng lặp! Để thực hành với các khái niệm được giới thiệu trong chương này, hãy thử
viết một chương trình làm những việc sau:</p>
<ul>
<li>Chuyển đổi nhiệt độ giữa các hệ Fahrenheit và Celsius.</li>
<li>Tạo số Fibonacci thứ n.</li>
<li>In ra lời bài hát “The Twelve Days of Christmas,”, ứng dụng các vòng lặp để in ra những đoạn lặp lại trong bài hát.</li>
</ul>
<p>Khi bạn đã sẵn sàng để tiếp tục, chúng ta sẽ nói về một khái niệm <em>không</em> tồn tại 
trong hầu hết các ngôn ngữ khác: ownership.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-04-comments.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-04-comments.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch04-00-understanding-ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
