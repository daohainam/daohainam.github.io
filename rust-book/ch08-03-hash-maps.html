<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Storing Keys with Associated Values in Hash Maps - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Ngôn ngữ lập trình Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Lời nói đầu</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Giới thiệu</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Bắt đầu</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Cài đặt</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Lập trình trò chơi đoán số</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Các khái niệm chung trong lập trình</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Biến và tính khả biến</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Các kiểu dữ liệu</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Hàm</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Ghi chú</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Các khối điều khiển</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Tìm hiểu về Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Ownership là gì?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Tham chiếu (reference) và mượn (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Kiểu Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Sử dụng Structs để kết hợp các dữ liệu có liên quan</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Định nghĩa và khởi tạo Struct</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Một ví dụ về lập trình với Struct</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Cú pháp phương thức</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Kiểu Enum và khớp mẫu</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Định nghĩa một Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Cấu trúc điều khiển match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Điều khiển luồng thực thi một các chính xác với if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html" class="active"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="lưu-trữ-khóa-với-giá-trị-liên-kết-trong-bản-đồ-băm-hash-map-accessing-values-in-a-hash-map"><a class="header" href="#lưu-trữ-khóa-với-giá-trị-liên-kết-trong-bản-đồ-băm-hash-map-accessing-values-in-a-hash-map">Lưu trữ khóa với giá trị liên kết trong bản đồ băm (Hash Map) {#accessing-values-in-a-hash-map}</a></h2>
<p>Phần tập hợp cuối cùng trong bộ các tập hợp phổ biến là <em>bản đồ băm</em>. Kiểu <code>HashMap&lt;K,V&gt;</code> lưu trữ ánh xạ các khóa kiểu <code>K</code> tới các giá trị kiểu <code>V</code> bằng cách sử dụng <em>hàm băm</em>, xác định cách nó thiết đặt khóa và giá trị vào bộ nhớ. Nhiều ngôn ngữ lập trình hỗ trợ loại cấu trúc dữ liệu này, nhưng chúng thường được dùng với một cái tên khác, chẳng hạn như băm (hash), bản đồ (map), đối tượng (object), bảng băm (hash table), từ điển (dictionary) hoặc mảng kết hợp, chỉ nêu ra một vài cái tên ví dụ như vậy.</p>
<p>Bản đồ băm rất hữu ích khi bạn muốn tra cứu dữ liệu không phải bằng cách sử dụng chỉ mục index như bạn có thể làm với vector, mà bằng cách sử dụng một khóa có thể là bất kỳ loại nào. Ví dụ: trong một trò chơi, bạn có thể theo dõi điểm số của mỗi đội trong một bản đồ băm trong đó mỗi khóa là tên của đội và các giá trị là điểm số của mỗi đội. Tương ứng với tên một đội, bạn có thể lấy điểm của đội đó.</p>
<p>Chúng ta sẽ xem xét API cơ bản của bản đồ băm trong phần này, có nhiều tính năng bổ sung khác đang ẩn trong các hàm được định nghĩa trong <code>HashMap&lt;K,V&gt;</code> bởi thư viện chuẩn. Như mọi khi, hãy tham khảo tài liệu thư viện tiêu chuẩn để biết thêm thông tin.</p>
<h3 id="tạo-mới-một-bản-đồ-băm-hash-map"><a class="header" href="#tạo-mới-một-bản-đồ-băm-hash-map">Tạo mới một bản đồ băm (hash map)</a></h3>
<p>Một cách để tạo một bản đồ băm rỗng là sử dụng <code>new</code> và thêm các phần tử bằng <code>insert</code>. Trong mục 8-20, chúng ta đang theo dõi điểm số của hai đội có tên là <em>Blue</em> và <em>Yellow</em>. Đội Blue bắt đầu với 10 điểm và đội Yellow bắt đầu với 50 điểm.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Mục 8-20: Tạo mới bản đồ băm và chèn vài cặp khóa-giá trị</span></p>
<p>Lưu ý rằng trước tiên chúng ta cần <code>use</code> bản đồ băm <code>HashMap</code> từ bộ tập hợp của thư viện chuẩn. Trong số ba bộ sưu tập phổ biến của chúng ta, loại này ít được sử dụng nhất, vì vậy nó không được đưa vào như những tính năng tự động trong phạm vi của prelude (có thể hiểu là các thư viện đính sẵn khi compile, chỉ cần sử dụng mà không cần khai báo tường minh). Bản đồ băm cũng ít hỗ trợ hơn từ thư viện chuẩn; chẳng hạn như không có macro tích hợp sẵn để tạo chúng.</p>
<p>Cũng giống như vector, bản đồ băm lưu trữ dữ liệu của chúng trên heap. <code>HashMap</code> này có các khóa kiểu <code>String</code> và các giá trị kiểu <code>i32</code>. Giống như vector, bản đồ băm là đồng nhất: tất cả các khóa phải có cùng kiểu với nhau và tất cả các giá trị phải có cùng kiểu.</p>
<h3 id="truy-cập-giá-trị-của-bản-đồ-băm-hash-map"><a class="header" href="#truy-cập-giá-trị-của-bản-đồ-băm-hash-map">Truy cập giá trị của bản đồ băm (hash map)</a></h3>
<p>Chúng ta có thể lấy một giá trị từ bản đồ băm bằng cách cung cấp khóa của nó cho phương thức <code>get</code>, như được hiển thị trong mục 8-21.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Mục 8-21: Truy cập điểm số của đội Blue lưu trong bản đồ băm</span></p>
<p>Ở đây, <code>score</code> sẽ có giá trị được liên kết với đội Blue và kết quả sẽ là <code>10</code>. Phương thức <code>get</code> trả về một <code>Option&lt;&amp;V&gt;</code>; nếu không có giá trị nào cho khóa đó trong bản đồ băm, <code>get</code> sẽ trả về <code>None</code>. Chương trình này sẽ cần phải xử lý <code>Option</code> bằng cách gọi <code>unsrap_or</code> để đặt <code>score</code> thành 0 nếu <code>scores</code> không có phần tử nào tương ứng với khóa.</p>
<p>Chúng ta có thể lặp qua từng cặp khóa/giá trị trong bản đồ băm theo cách tương tự như khi chúng ta làm với vector, bằng cách sử dụng vòng lặp <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{key}: {value}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>Đoạn code này sẽ in ra từng cặp theo thứ tự tùy ý:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="bản-đồ-băm-và-quyền-sở-hữu-ownership"><a class="header" href="#bản-đồ-băm-và-quyền-sở-hữu-ownership">Bản đồ băm và quyền sở hữu (ownership)</a></h3>
<p>Đối với những kiểu dữ liệu triển khai từ đối tượng đặc tả <code>Copy</code>, như <code>i32</code>, các giá trị được sao chép vào bản đồ băm. Đối với các giá trị được sở hữu như <code>String</code>, các giá trị sẽ được di chuyển và bản đồ băm sẽ là chủ sở hữu của các giá trị đó, như được minh họa trong mục 8-22.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from(&quot;Favorite color&quot;);
    let field_value = String::from(&quot;Blue&quot;);

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Mục 8-22: Các khóa và giá trị thuộc sở hữu của
bản đồ băm sau khi chúng được thêm vào</span></p>
<p>Chúng ta không thể sử dụng các biến <code>field_name</code> và <code>field_value</code> sau khi chúng được chuyển vào bản đồ băm với lệnh gọi <code>insert</code>.</p>
<p>Nếu chúng ta thêm tham chiếu (đến các giá trị) vào bản đồ băm, thì giá trị sẽ không được chuyển vào bản đồ băm. Các giá trị mà các tham chiếu trỏ đến phải hợp lệ ít nhất là trong thời gian bản đồ băm vẫn còn hợp lệ. Chúng ta sẽ nói thêm về những vấn đề này trong phần <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“Xác thực tham chiếu với vòng đời (lifetime)”</a><!-- ignore --> ở Chương 10.</p>
<h3 id="cập-nhật-bản-đồ-băm"><a class="header" href="#cập-nhật-bản-đồ-băm">Cập nhật bản đồ băm</a></h3>
<p>Mặc dù số lượng cặp khóa-giá trị có thể tăng lên, nhưng mỗi khóa duy nhất chỉ có thể có một giá trị được liên kết với nó tại một thời điểm (điều này không áp dụng ngược lại: ví dụ: cả đội Blue và đội Yellow đều có thể có giá trị 10 được lưu trữ trong bản đồ băm <code>scores</code>).</p>
<p>Khi bạn muốn thay đổi dữ liệu trong bản đồ băm, bạn phải quyết định cách xử lý trường hợp khi một khóa đã được gán giá trị. Bạn có thể thay thế giá trị cũ bằng giá trị mới, có nghĩa là hoàn toàn bỏ qua giá trị cũ. Bạn có thể giữ giá trị cũ và bỏ qua giá trị mới, chỉ thêm giá trị mới nếu khóa <em>không</em> có giá trị. Hoặc bạn có thể kết hợp giá trị cũ và giá trị mới. Hãy xem cách thực hiện từng điều này!</p>
<h4 id="ghi-đè-một-giá-trị"><a class="header" href="#ghi-đè-một-giá-trị">Ghi đè một giá trị</a></h4>
<p>Nếu chúng ta thêm một khóa-giá trị vào một bản đồ băm và sau đó lại chèn thêm cùng một khóa đó bằng một giá trị khác, thì giá trị được liên kết với khóa đó sẽ bị thay thế. Mặc dù mã trong mục 8-23 gọi <code>insert</code> hai lần, nhưng bản đồ băm sẽ chỉ chứa một cặp khóa-giá trị vì chúng ta đang chèn giá trị cho khóa của đội Blue cả hai lần.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Blue&quot;), 25);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Mục 8-23: Thay thế giá trị lưu trữ bằng khóa cụ thể</span></p>
<p>Đoạn mã này sẽ in <code>{&quot;Blue&quot;: 25}</code>. Giá trị ban đầu của <code>10</code> đã bị ghi đè</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="thêm-khóa-giá-trị-nếu-khóa-chưa-tồn-tại"><a class="header" href="#thêm-khóa-giá-trị-nếu-khóa-chưa-tồn-tại">Thêm khóa-giá trị nếu khóa chưa tồn tại</a></h4>
<p>Thông thường, để kiểm tra xem một khóa cụ thể đã tồn tại trong bản đồ băm với một giá trị hay chưa, chúng ta sẽ thực hiện thao tác sau: nếu khóa tồn tại trong bản đồ băm, giá trị hiện có sẽ vẫn như cũ, nếu khóa không tồn tại, hãy chèn khóa và giá trị cho nó.</p>
<p>Bản đồ băm có một API đặc biệt cho điều này được gọi là <code>entry</code>, nó có tham số là khóa bạn muốn kiểm tra. Giá trị trả về của phương thức <code>entry</code> là một enum được gọi là <code>Entry</code> đại diện cho một giá trị có thể tồn tại hoặc không. Giả sử chúng ta muốn kiểm tra xem khóa của đội Yellow có giá trị liên kết với nó hay không. Nếu không, chúng ta muốn chèn giá trị 50 và làm điều tương tự với cho đội Blue. Sử dụng API <code>entry</code>, đoạn mã trông giống như mục 8-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10);

    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Mục 8-24: Dùng phương thức <code>entry</code> để chỉ thêm vào nếu key không tồn tại giá trị nào</span></p>
<p>Phương thức <code>or_insert</code> trên <code>Entry</code> được xác định để trả về một tham chiếu mutable tham chiếu đến giá trị cho khóa <code>Entry</code> tương ứng nếu khóa đó tồn tại, và nếu không thì hãy thiết lập giá trị của tham số cho khóa này và trả về một tham chiếu mutable tham chiếu tới giá trị mới. Kỹ thuật này gọn hơn nhiều so với việc tự viết logic, và ngoài ra nó hoạt động độc đáo hơn với trình kiểm tra mượn tham chiếu.</p>
<p>Chạy đoạn mã trong mục 8-24 sẽ in ra <code>{&quot; Yellow &quot;: 50,&quot; Blue &quot;: 10}</code>. Lệnh gọi <code>entry</code> đầu tiên sẽ chèn khóa cho đội Yellow với giá trị 50 vì đội Yellow chưa có giá trị. Lần gọi <code>entry</code> thứ hai sẽ không thay đổi bản đồ băm vì đội Blue đã có giá trị 10 sẵn.</p>
<h4 id="cập-nhật-giá-trị-dựa-trên-giá-trị-cũ"><a class="header" href="#cập-nhật-giá-trị-dựa-trên-giá-trị-cũ">Cập nhật giá trị dựa trên giá trị cũ</a></h4>
<p>Một trường hợp sử dụng phổ biến khác cho bản đồ băm là tìm kiếm giá trị của khóa và sau đó cập nhật nó dựa trên giá trị cũ. Ví dụ: mục 8-25 là đoạn code xử lý đếm số lần xuất hiện của mỗi từ trong một văn bản. Chúng ta sử dụng bản đồ băm sử dụng mỗi từ ngữ làm khóa và tăng giá trị để theo dõi số lần xuất hiện của chúng. Nếu đây là lần đầu tiên chúng ta nhìn thấy một từ, trước tiên chúng ta sẽ thiết lập giá trị là 0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = &quot;hello world wonderful world&quot;;

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!(&quot;{:?}&quot;, map);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Mục 8-25: Đếm số lần xuất hiện của các từ ngữ bằng cách sử dụng bản đồ băm lưu trữ các từ và số đếm</span></p>
<p>Đoạn mã này sẽ in ra <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. Bạn có thể thấy các cặp khóa-giá trị giống nhau được in theo một thứ tự khác nhau: nhớ lại từ phần <a href="#accessing-values-in-a-hash-map">“Truy cập giá trị của bản đồ băm”</a><!-- ignore --> mà việc lặp qua bản đồ băm diễn ra theo thứ tự tùy ý.</p>
<p>Phương thức <code>split_whitespace</code> trả về một bộ lặp duyệt qua các đoạn nhỏ được phân tách bằng khoảng trắng của giá trị trong <code>text</code>. Phương thức <code>or_insert</code> trả về một tham chiếu mutable (<code>&amp;mut V</code>) trỏ đến giá trị cho khóa được chỉ định. Ở đây chúng ta lưu trữ tham chiếu mutable đó trong biến <code>count</code>, vì vậy để gán cho giá trị đó, trước tiên chúng ta phải bỏ tham chiếu (deref) <code>count</code> bằng cách sử dụng dấu hoa thị (<code>*</code>). Tham chiếu mutable sẽ nằm ngoài phạm vi ở cuối vòng lặp <code>for</code>, vì vậy tất cả những thay đổi này đều an toàn và được các quy tắc mượn tham chiếu cho phép.</p>
<h3 id="hàm-băm"><a class="header" href="#hàm-băm">Hàm băm</a></h3>
<p>Theo mặc định, <code>HashMap</code> sử dụng một hàm băm được gọi là <em>SipHash</em> có thể cung cấp khả năng chống lại các cuộc tấn công Từ chối Dịch vụ (DoS) liên quan đến các bảng băm<sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore -->. Đây không phải là thuật toán băm nhanh nhất hiện có, nhưng việc đánh đổi hiệu suất để mang lại bảo mật tốt hơn cũng là điều đáng giá. Nếu bạn kiểm tra các đoạn mã của mình và nhận thấy rằng hàm băm mặc định quá chậm so với mục đích của bạn, bạn có thể chuyển sang một hàm khác bằng cách chỉ định một bộ băm (hasher) khác. Một <em>hasher</em> là một kiểu triển khai của đối tượng đặc tả (trait) <code>BuildHasher</code>. Chúng ta sẽ nói về các trait và cách triển khai chúng trong Chương 10. Bạn không nhất thiết phải triển khai hàm băm của riêng mình từ đầu; <a href="https://crates.io/">crates.io</a><!-- ignore --> có các thư viện được chia sẻ bởi những người dùng Rust khác cung cấp nhiều bộ băm cho rất nhiều thuật toán băm thông dụng.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="tổng-kết-lại"><a class="header" href="#tổng-kết-lại">Tổng kết lại</a></h2>
<p>Vector, chuỗi và bản đồ băm cung cấp một lượng lớn chức năng cần thiết trong các chương trình khi bạn cần lưu trữ, truy cập và sửa đổi dữ liệu. Dưới đây là một số bài tập bạn nên trang bị để giải quyết:</p>
<ul>
<li>Cho một danh sách các số nguyên, hãy sử dụng một vector và trả về giá trị trung vị (khi được sắp
xếp, giá trị ở vị trí giữa) và mode của (giá trị xuất hiện thường xuyên nhất; bản đồ băm sẽ hữu ích trường hợp này) của danh sách.</li>
<li>Chuyển đổi chuỗi sang pig latin. Phụ âm đầu tiên của mỗi từ được chuyển đến cuối từ và “ay”
được thêm vào, vì vậy “first” trở thành “irst-fay”. Thay vào đó, những từ bắt đầu bằng một nguyên âm sẽ được thêm “hay” vào cuối (“apple” trở thành “apple-hay”). Hãy ghi nhớ các chi tiết về mã hóa UTF-8!</li>
<li>Sử dụng bản đồ băm và vector, tạo giao diện văn bản để cho phép người dùng thêm tên nhân viên vào
một phòng ban trong công ty. Ví dụ: “Thêm Sally vào Kỹ thuật” hoặc “Thêm Amir vào Bán hàng”. Sau đó, cho phép người dùng truy xuất danh sách tất cả những người trong một bộ phận hoặc tất cả những người trong công ty theo từng bộ phận, được sắp xếp theo thứ tự bảng chữ cái.</li>
</ul>
<p>Tài liệu API thư viện tiêu chuẩn mô tả các phương thức mà vector, chuỗi và bản đồ băm có, sẽ hữu ích cho các bài tập này!</p>
<p>Chúng ta đang tiến đến các chương trình phức tạp hơn, mà trong đó các thao tác có thể bị lỗi, vì vậy, đây là thời điểm hoàn hảo để thảo luận về việc xử lý lỗi. Chúng ta sẽ làm điều đó tiếp theo!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-02-strings.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-00-error-handling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-02-strings.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-00-error-handling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
