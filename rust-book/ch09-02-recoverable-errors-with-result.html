<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Recoverable Errors with Result - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Ngôn ngữ lập trình Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Cài đặt</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html" class="active"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="recoverable-errors-with-result"><a class="header" href="#recoverable-errors-with-result">Recoverable Errors with <code>Result</code></a></h2>
<p>Hầu hết các lỗi không đủ nghiêm trọng để yêu cầu chương trình dừng hoàn toàn.
Đôi khi, khi một hàm thất bại, nó là vì một lý do mà bạn có thể dễ dàng diễn
giải và phản ứng. Ví dụ, nếu bạn cố gắng mở một tệp và hoạt động thất bại bởi
vì tệp không tồn tại, bạn có thể muốn tạo tệp thay vì kết thúc quá trình.</p>
<p>Nhắc lại từ <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“Handling Potential Failure with the <code>Result</code>
Type”</a><!-- ignore --> trong Chương 2 rằng <code>Result</code> enum được
định nghĩa là có hai biến thể, <code>Ok</code> và <code>Err</code>, như sau:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code> và <code>E</code> là các tham số kiểu generic: chúng ta sẽ thảo luận về generic kỹ
hơn trong Chương 10. Bạn cần biết ngay bây giờ là <code>T</code> biểu diễn kiểu của giá
trị sẽ được trả về trong trường hợp thành công trong biến thể <code>Ok</code>, và <code>E</code>
biểu diễn kiểu của lỗi sẽ được trả về trong trường hợp thất bại trong biến
thể <code>Err</code>. Bởi vì <code>Result</code> có các tham số kiểu generic này, chúng ta có thể sử
dụng kiểu <code>Result</code> và các hàm được định nghĩa trên nó trong nhiều tình huống
khác nhau mà giá trị thành công và giá trị lỗi mà chúng ta muốn trả về có thể
khác nhau.</p>
<p>Cùng gọi một hàm mà trả về một giá trị <code>Result</code> bởi vì hàm có thể thất bại.
Trong Listing 9-3 chúng ta cố gắng mở một tệp.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 9-3: Mở một tệp</span></p>
<p>Kiểu trả về của <code>File::open</code> là <code>Result&lt;T, E&gt;</code>. Tham số kiểu generic <code>T</code>
được điền vào bởi hiện thực <code>File::open</code> với kiểu của giá trị khi gọi thành
công là <code>std::fs::File</code>, đó là một file handle. Kiểu của <code>E</code> được sử dụng trong
giá và giá trị lỗi là <code>std::io::Error</code>. Kiểu trả về này có nghĩa là lời gọi đến
<code>File::open</code> có thể thành công và trả về một file handle mà chúng ta có thể
đọc hoặc ghi. Lời gọi hàm cũng có thể thất bại: ví dụ, tệp có thể không tồn tại,
hoặc chúng ta có thể không có quyền truy cập tệp. Hàm <code>File::open</code> cần phải có
một cách để cho chúng ta biết nó đã thành công hay thất bại và cùng lúc cho
chúng ta một file handle hoặc thông tin về lỗi. Thông tin này chính là những
gì enum <code>Result</code> truyền tải.</p>
<p>Trong trường hợp <code>File::open</code> thành công, giá trị trong biến
<code>greeting_file_result</code> sẽ là một thể hiện của <code>Ok</code> chứa một file handle. Trong
trường hợp nó thất bại, giá trị trong <code>greeting_file_result</code> sẽ là một thể hiện
của <code>Err</code> chứa thêm thông tin về loại lỗi đã xảy ra.</p>
<p>Chúng ta cần thêm vào code trong Listing 9-3 để thực hiện các hành động khác
nhau tùy thuộc vào giá trị mà <code>File::open</code> trả về. Listing 9-4 cho thấy một
cách để xử lý <code>Result</code> sử dụng một công cụ cơ bản, biểu thức <code>match</code> mà chúng
ta đã thảo luận trong Chương 6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error),
    };
}</code></pre></pre>
<p><span class="caption">Listing 9-4: Sử dụng biểu thức <code>match</code> để xử lý các
thể hiện <code>Result</code> có thể được trả về</span></p>
<p>Chú ý rằng, giống như enum <code>Option</code>, enum <code>Result</code> và các biến thể của nó đã
được đưa vào scope bởi prelude, vì vậy chúng ta không cần chỉ định <code>Result::</code>
trước các biến thể <code>Ok</code> và <code>Err</code> trong các nhánh của <code>match</code>.</p>
<p>Khi kết quả là <code>Ok</code>, code này sẽ trả về giá trị nội bộ <code>file</code> bên trong biến
thể <code>Ok</code>, và chúng ta sau đó gán giá trị file handle đó cho biến
<code>greeting_file</code>. Sau <code>match</code>, chúng ta có thể sử dụng file handle để đọc hoặc
ghi.</p>
<p>Nhánh còn lại của <code>match</code> xử lý trường hợp chúng ta nhận được một giá trị <code>Err</code>
từ <code>File::open</code>. Trong ví dụ này, chúng ta đã chọn gọi macro <code>panic!</code>. Nếu
không có tệp nào có tên <em>hello.txt</em> trong thư mục hiện tại của chúng ta và chúng
ta chạy mã này, chúng ta sẽ thấy đầu ra sau từ macro <code>panic!</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Như thường lệ, output này cho chúng ta biết chính xác lỗi là gì.</p>
<h3 id="matching-on-different-errors"><a class="header" href="#matching-on-different-errors">Matching on Different Errors</a></h3>
<p>Code trong Listing 9-4 sẽ <code>panic!</code> bất kể lý do nào mà <code>File::open</code> thất bại.
Tuy nhiên, chúng ta muốn thực hiện các hành động khác nhau cho các lý do thất
bại khác nhau: nếu <code>File::open</code> thất bại vì tệp không tồn tại, chúng ta muốn
tạo tệp và trả về handle đến tệp mới. Nếu <code>File::open</code> thất bại vì bất kỳ lý
do nào khác - ví dụ, vì chúng ta không có quyền mở tệp - chúng ta vẫn muốn mã
<code>panic!</code> theo cách giống như trong Listing 9-4. Để làm điều này, chúng ta thêm
một biểu thức <code>match</code> bên trong, được hiển thị trong Listing 9-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),
            },
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {:?}&quot;, other_error);
            }
        },
    };
}</code></pre>
<p><span class="caption">Listing 9-5: Xử lý các loại lỗi khác nhau theo các cách
khác nhau</span></p>
<p>Kiểu của giá trị mà <code>File::open</code> trả về bên trong biến <code>Err</code> là <code>io::Error</code>,
một struct được cung cấp bởi thư viện chuẩn. Struct này có một phương thức
<code>kind</code> mà chúng ta có thể gọi để lấy một giá trị <code>io::ErrorKind</code>. Enum
<code>io::ErrorKind</code> được cung cấp bởi thư viện chuẩn và có các biến thể biểu
thị các loại lỗi khác nhau có thể xảy ra từ một hoạt động <code>io</code>. Biến thể mà
chúng ta muốn sử dụng là <code>ErrorKind::NotFound</code>, biểu thị tệp mà chúng ta đang
cố gắng mở không tồn tại. Do đó, chúng ta <code>match</code> trên <code>greeting_file_result</code>,
nhưng chúng ta cũng có một <code>match</code> bên trong trên <code>error.kind()</code>.</p>
<p>Điều kiện mà chúng ta muốn kiểm tra trong <code>match</code> bên trong là liệu giá trị
trả về bởi <code>error.kind()</code> có phải là biến thể <code>NotFound</code> của enum <code>ErrorKind</code>.
Nếu có, chúng ta cố gắng tạo tệp với <code>File::create</code>. Tuy nhiên, vì
<code>File::create</code> cũng có thể thất bại, chúng ta cần một biến thể thứ hai trong
biểu thức <code>match</code> bên trong. Khi tệp không thể được tạo, một thông báo lỗi
khác được in ra. Biến thể thứ hai của <code>match</code> bên ngoài vẫn giữ nguyên, vì vậy
chương trình sẽ bị panic với bất kỳ lỗi nào ngoài lỗi tệp thiếu.</p>
<blockquote>
<h3 id="alternatives-to-using-match-with-resultt-e"><a class="header" href="#alternatives-to-using-match-with-resultt-e">Alternatives to Using <code>match</code> with <code>Result&lt;T, E&gt;</code></a></h3>
<p>Có quá nhiều <code>match</code>! Biểu thức <code>match</code> rất hữu ích nhưng vẫn là một biểu thức
cơ bản. Trong Chương 13, bạn sẽ tìm hiểu về closures, được sử dụng với nhiều
phương thức được định nghĩa trên <code>Result&lt;T, E&gt;</code>. Những phương thức này có thể
ngắn gọn hơn so với việc sử dụng <code>match</code> khi xử lý giá trị <code>Result&lt;T, E&gt;</code>
trong code của bạn</p>
<p>Ví dụ, đây là một cách khác để viết cùng một logic như trong Listing 9-5,
lần này sử dụng closures và phương thức <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem opening the file: {:?}&quot;, error);
        }
    });
}</code></pre>
<p>Mặc dù code này có cùng hành vi như Listing 9-5, nó không chứa bất kỳ biểu
thức <code>match</code> nào và dễ đọc hơn. Quay lại ví dụ này sau khi bạn đã đọc Chương
13, và tìm kiếm phương thức <code>unwrap_or_else</code> trong tài liệu thư viện chuẩn.
Nhiều phương thức khác có thể  làm ngắn gọn các biểu thức <code>match</code> lồng nhau
lớn khi bạn đang xử lý các lỗi.</p>
</blockquote>
<hr />
<h3 id="shortcuts-for-panic-on-error-unwrap-and-expect"><a class="header" href="#shortcuts-for-panic-on-error-unwrap-and-expect">Shortcuts for Panic on Error: <code>unwrap</code> and <code>expect</code></a></h3>
<p>Sử dụng <code>match</code> thường tốt, nhưng nó có thể rất dài dòng và khó hiểu.
Kiểu <code>Result&lt;T, E&gt;</code> có nhiều phương thức trợ giúp được định nghĩa trên nó để
thực hiện các tác vụ cụ thể hơn. Phương thức <code>unwrap</code> là một phương thức tắt
được thực hiện giống như biểu thức <code>match</code> mà chúng ta đã viết trong Listing
9-4. Nếu giá trị <code>Result</code> là biến <code>Ok</code>, <code>unwrap</code> sẽ trả về giá trị bên trong
biến <code>Ok</code>. Nếu <code>Result</code> là biến <code>Err</code>, <code>unwrap</code> sẽ gọi macro <code>panic!</code> giúp
chúng ta. Đây là một ví dụ về <code>unwrap</code> hoạt động:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap();
}</code></pre></pre>
<p>Nếu chúng ta chạy code này mà không có file <em>hello.txt</em>, chúng ta sẽ thấy một
thông báo lỗi từ lệnh <code>panic!</code> mà phương thức <code>unwrap</code> gọi:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Tương tự, phương thức <code>expect</code> cho phép chúng ta chọn thông báo lỗi <code>panic!</code>.
Sử dụng <code>expect</code> thay vì <code>unwrap</code> và cung cấp các thông báo lỗi tốt có thể
truyền đạt ý định của bạn và làm cho việc tìm nguyên nhân của một lỗi dễ dàng
hơn. Cú pháp của <code>expect</code> như sau:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)
        .expect(&quot;hello.txt should be included in this project&quot;);
}</code></pre></pre>
<p>Chúng ta sử dụng <code>expect</code> theo cách giống như <code>unwrap</code>: để trả về file handle
hoặc gọi macro <code>panic!</code>. Thông báo lỗi được sử dụng bởi <code>expect</code> trong lệnh
<code>panic!</code> sẽ là tham số mà chúng ta truyền cho <code>expect</code>, thay vì thông báo lỗi
mặc định của <code>panic!</code> mà <code>unwrap</code> sử dụng. Đây là cách nó hoạt động:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'hello.txt should be included in this project: Error
{ repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Trong code ở production, hầu hết Rustaceans (người dùng Rust) chọn
<code>expect</code> thay vì <code>unwrap</code> và cung cấp thêm thông tin về tại sao các hoạt động
được mong đợi là luôn thành công. Điều đó cho phép bạn có thêm thông tin để
sử dụng trong quá trình debug nếu như các giả định của bạn bị chứng minh sai.</p>
<hr />
<h3 id="propagating-errors"><a class="header" href="#propagating-errors">Propagating Errors</a></h3>
<p>Khi một hàm thực thi gọi một thứ gì đó có thể gây ra lỗi, thay vì xử lý lỗi
trong hàm thực thi, bạn có thể trả về lỗi cho code gọi hàm để nó có thể quyết
định làm gì. Điều này được gọi là <em>propagating (lan truyền)</em> lỗi và cho phép
code gọi đến hàm có thể quyết định xử lý lỗi theo cách nào mà nó thích hơn.</p>
<p>Ví dụ, Listing 9-6 cho thấy một hàm đọc username từ một file. Nếu file không
tồn tại hoặc không thể đọc được, hàm này sẽ trả về lỗi đó cho code gọi hàm.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open(&quot;hello.txt&quot;);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-6: Một hàm trả về lỗi cho code gọi hàm sử dụng
<code>match</code></span></p>
<p>Hàm này có thể được viết ngắn gọn hơn, nhưng chúng ta sẽ bắt đầu bằng cách
viết nó một cách thủ công để khám phá về xử lý lỗi; ở cuối, chúng ta sẽ cho
thấy cách viết ngắn gọn hơn. Hãy xem kiểu trả về của hàm trước tiên:
<code>Result&lt;String, io::Error&gt;</code>. Điều này có nghĩa là hàm trả về một giá trị của
kiểu <code>Result&lt;T, E&gt;</code> với tham số <code>T</code> được điền vào với kiểu cụ thể <code>String</code>,
và kiểu <code>E</code> được điền vào với kiểu cụ thể <code>io::Error</code>.</p>
<p>Nếu hàm này thành công mà không có vấn đề gì, code gọi hàm này sẽ nhận được
một giá trị <code>Ok</code> chứa một <code>String</code> - username mà hàm này đọc từ file. Nếu hàm
này gặp bất kỳ vấn đề nào, code gọi hàm sẽ nhận được một giá trị <code>Err</code> chứa một
thể hiện của <code>io::Error</code> chứa thông tin chi tiết về vấn đề. Chúng ta chọn
<code>io::Error</code> là kiểu trả về của hàm này vì đó chính là kiểu của giá trị lỗi
trả về từ cả hai hoạt động mà chúng ta gọi trong thân hàm này có thể gặp lỗi:
hàm <code>File::open</code> và phương thức <code>read_to_string</code>.</p>
<p>Thân hàm bắt đầu bằng cách gọi hàm <code>File::open</code>. Sau đó chúng ta xử lý giá trị
<code>Result</code> với một <code>match</code> giống như <code>match</code> trong Listing 9-4. Nếu <code>File::open</code>
thành công, file handle trong biến mẫu <code>file</code> trở thành giá trị trong biến
<code>username_file</code> và hàm tiếp tục. Trong trường hợp <code>Err</code>, thay vì gọi <code>panic!</code>,
chúng ta sử dụng từ khóa <code>return</code> để trả về sớm và trả về giá trị lỗi từ
<code>File::open</code>, giờ đây trong biến mẫu <code>e</code>, về code gọi hàm như là giá trị lỗi
của hàm này.</p>
<p>Nên nếu chúng ta có một file handle trong <code>username_file</code>,
chúng ta sẽ tạo một biến kiêu <code>String</code> mới với tên <code>username</code>
và gọi phương thức <code>read_to_string</code> của
file handle trong <code>username_file</code> để đọc nội dung của file vào <code>username</code>.
Phương thức <code>read_to_string</code> cũng trả về một <code>Result</code> vì nó có thể gặp lỗi,
dù <code>File::open</code> đã thành công. Vì vậy chúng ta cần một <code>match</code> khác để xử lý
<code>Result</code>: nếu <code>read_to_string</code> thành công, thì hàm của chúng ta đã thành công,
và chúng ta trả về username từ file hiện tại trong <code>username</code> được bọc trong
một <code>Ok</code>. Nếu <code>read_to_string</code> gặp lỗi, chúng ta trả về giá trị lỗi theo cách
giống như chúng ta trả về giá trị lỗi trong <code>match</code> xử lý giá trị trả về của
<code>File::open</code>. Tuy nhiên, chúng ta không cần phải nói rõ <code>return</code>, vì đây là
biểu thức cuối cùng trong hàm.</p>
<p>Đoạn code gọi hàm này sẽ xử lý việc nhận được một giá trị <code>Ok</code> chứa một username
hoặc một giá trị <code>Err</code> chứa một <code>io::Error</code>. Nó phụ thuộc vào code gọi hàm để
quyết định làm gì với những giá trị này. Nếu code gọi hàm nhận được một giá trị
<code>Err</code>, nó có thể gọi <code>panic!</code> và crash chương trình, sử dụng một username mặc
định, hoặc tìm kiếm username từ một nơi khác ngoài file, ví dụ. Chúng ta không
có đủ thông tin về việc code gọi hàm thực sự muốn làm gì, vì vậy chúng ta truyền
tất cả thông tin thành công hoặc lỗi lên trên để code gọi hàm xử lý phù hợp.</p>
<p>Phương pháp truyền lỗi này rất phổ biến trong Rust, vì vậy Rust cung cấp
phép toán dấu hỏi <code>?</code> để làm cho việc này dễ dàng hơn.</p>
<h4 id="a-shortcut-for-propagating-errors-the--operator"><a class="header" href="#a-shortcut-for-propagating-errors-the--operator">A Shortcut for Propagating Errors: the <code>?</code> Operator</a></h4>
<p>Listing 9-7 chỉ ra một cách code của <code>read_username_from_file</code> có cùng chức
năng như trong Listing 9-6, nhưng cách code này sử dụng phép toán <code>?</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open(&quot;hello.txt&quot;)?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-7: Một hàm trả về lỗi cho code gọi hàm sử dụng
phép toán <code>?</code></span></p>
<p>Phép toán <code>?</code> được định nghĩa để hoạt động gần như giống như các biểu thức
<code>match</code> mà chúng ta định nghĩa để xử lý các giá trị <code>Result</code> trong Listing
9-6. Nếu giá trị của <code>Result</code> là <code>Ok</code>, giá trị bên trong <code>Ok</code> sẽ được trả về
từ biểu thức này, và chương trình sẽ tiếp tục. Nếu giá trị là <code>Err</code>, <code>Err</code> sẽ
được trả về trả về sớm và kết thúc hàm, giống cách chúng ta dùng <code>return</code>.</p>
<p>Có một sự khác biệt giữa việc biểu thức <code>match</code> từ Listing 9-6 làm gì và việc
phép toán <code>?</code> làm gì: các giá trị lỗi mà có phép toán <code>?</code> được gọi sẽ đi qua
hàm <code>from</code>, được định nghĩa trong trait <code>From</code> của thư viện chuẩn, được sử
dụng để chuyển đổi giá trị từ một kiểu thành một kiểu khác. Khi phép toán <code>?</code>
gọi hàm <code>from</code>, kiểu lỗi nhận được sẽ được chuyển đổi thành kiểu lỗi được định
nghĩa trong kiểu trả về của hàm hiện tại. Điều này rất hữu ích khi một hàm trả
về một kiểu lỗi để biểu diễn tất cả các cách mà một hàm có thể thất bại, ngay cả
khi các phần có thể thất bại vì nhiều lý do khác nhau.</p>
<p>Ví dụ, chúng ta có thể thay đổi hàm <code>read_username_from_file</code> trong Listing
9-7 để trả về một kiểu lỗi tùy chỉnh được đặt tên là <code>OurError</code> mà chúng ta
định nghĩa. Nếu chúng ta cũng định nghĩa <code>impl From&lt;io::Error&gt; for OurError</code>
để tạo một thể hiện của <code>OurError</code> từ một <code>io::Error</code>, thì phép toán <code>?</code> sẽ
gọi <code>from</code> và chuyển đổi kiểu lỗi mà không cần thêm bất kì đoạn mã nào vào
hàm.</p>
<p>Trong ngữ cảnh của Listing 9-7, phép toán <code>?</code> ở cuối lời gọi <code>File::open</code> sẽ
trả về giá trị bên trong một <code>Ok</code> cho biến <code>username_file</code>. Nếu xảy ra lỗi,
phép toán <code>?</code> sẽ trả về sớm và trả bất kì giá trị <code>Err</code> nào
cho code gọi hàm. Điều đó cũng được áp dụng cho phép toán <code>?</code> ở cuối lời gọi
<code>read_to_string</code>.</p>
<p>Phép toán <code>?</code> loại bỏ rất nhiều đoạn mã lặp đi và làm cho việc triển khai hàm
trở nên đơn giản hơn. Chúng ta có thể rút ngắn đoạn mã này thêm bằng cách
liên tiếp gọi các phương thức ngay sau phép toán <code>?</code>, như trong Listing 9-8.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-8: Liên tiếp gọi các phương thức sau phép toán
<code>?</code></span></p>
<p>Chúng ta tạo một biến <code>String</code> tên <code>username</code> ở đầu hàm; phần đó không
thay đổi. Thay vì tạo một biến <code>username_file</code>, chúng ta liên tiếp gọi phương
thức <code>read_to_string</code> trực tiếp trên kết quả của <code>File::open(&quot;hello.txt&quot;)?</code>.
Chúng ta vẫn có một <code>?</code> ở cuối lời gọi <code>read_to_string</code> và chúng ta vẫn trả về
một giá trị <code>Ok</code> chứa <code>username</code> khi cả <code>File::open</code> và <code>read_to_string</code>
thành công thay vì trả về lỗi. Chức năng vẫn giống như trong Listing 9-6 và
Listing 9-7; đây chỉ là một cách khác, dễ dùng hơn để viết nó.</p>
<p>Listing 9-9 cho thấy một cách để làm cho đoạn mã này ngắn hơn bằng cách sử
dụng <code>fs::read_to_string</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-9: Sử dụng <code>fs::read_to_string</code> thay vì mở và
sau đó đọc file</span></p>
<p>Đọc một file vào một chuỗi là một thao tác rất phổ biến, vì vậy thư viện chuẩn
cung cấp một hàm tiện lợi <code>fs::read_to_string</code> để mở file, tạo một <code>String</code>
mới, đọc nội dung của file, đặt nội dung vào <code>String</code> đó và trả về nó. Đương
nhiên, sử dụng <code>fs::read_to_string</code> không cho chúng ta cơ hội để giải thích
tất cả các xử lý lỗi, vì vậy chúng ta đã làm theo cách dài hơn trước.</p>
<hr />
<h4 id="where-the--operator-can-be-used"><a class="header" href="#where-the--operator-can-be-used">Where The <code>?</code> Operator Can Be Used</a></h4>
<p>Toán tử <code>?</code> chỉ có thể được sử dụng trong các hàm mà kiểu trả về là tương
thích với giá trị mà <code>?</code> được sử dụng. Điều này là bởi vì toán tử <code>?</code> được định
nghĩa để thực hiện một yêu cầu trả về sớm của một giá trị ra khỏi hàm,
cùng một cách như biểu thức <code>match</code> mà chúng ta định nghĩa trong Listing 9-6.
Trong Listing 9-6, <code>match</code> sử dụng một giá trị <code>Result</code>, và trả về sớm một giá
trị <code>Err(e)</code>. Kiểu trả về của hàm phải là một <code>Result</code> để nó tương thích với
trả về sớm của lệnh <code>return</code>.</p>
<p>Trong Listing 9-10, hãy xem lỗi mà chúng ta sẽ nhận được nếu chúng ta sử dụng
toán tử <code>?</code> trong một hàm <code>main</code> với kiểu trả về không tương thích với kiểu của
giá trị mà chúng ta sử dụng <code>?</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;
}</code></pre>
<p><span class="caption">Listing 9-10: Cố gắng sử dụng <code>?</code> trong hàm <code>main</code> trả
về <code>()</code> sẽ không biên dịch được</span></p>
<p>Đoạn code này mở một file, có thể sẽ thất bại. Toán tử <code>?</code> theo sau giá trị
<code>Result</code> được trả về bởi <code>File::open</code>, nhưng hàm <code>main</code> này có kiểu trả về là
<code>()</code>, không phải <code>Result</code>. Khi chúng ta biên dịch đoạn code này, chúng ta sẽ
nhận được lỗi như sau:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open(&quot;hello.txt&quot;)?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<p>Lỗi này chỉ ra rằng chúng ta chỉ được phép sử dụng toán tử <code>?</code> trong một hàm
trả về <code>Result</code>, <code>Option</code>, hoặc một kiểu khác mà nó triển khai <code>FromResidual</code>.</p>
<p>Để sửa lỗi, chúng ta có hai lựa chọn. Lựa chọn đầu tiên là thay đổi kiểu trả về
của hàm để tương thích với giá trị mà chúng ta đang sử dụng toán tử <code>?</code>
trong khi không có giới hạn nào ngăn cản điều đó. Cách khác là sử dụng một
<code>match</code> hoặc một trong các phương thức của <code>Result&lt;T, E&gt;</code> để xử lý 
<code>Result&lt;T, E&gt;</code> theo cách phù hợp.</p>
<p>Lỗi còn nói rằng <code>?</code> có thể được sử dụng với giá trị <code>Option&lt;T&gt;</code> cũng như vậy.
Giống như sử dụng <code>?</code> trên <code>Result</code>, chúng ta chỉ có thể sử dụng <code>?</code> trên
<code>Option</code> trong một hàm trả về <code>Option</code>. Hành vi của toán tử <code>?</code> khi được gọi
trên một <code>Option&lt;T&gt;</code> tương tự như hành vi của nó khi được gọi trên một
<code>Result&lt;T, E&gt;</code>: nếu giá trị là <code>None</code>, <code>None</code> sẽ được trả về sớm từ hàm tại
điểm đó. Nếu giá trị là <code>Some</code>, giá trị bên trong <code>Some</code>
sẽ là giá trị kết quả của biểu thức và hàm sẽ tiếp tục. Listing 9-11 có một
ví dụ về một hàm tìm ký tự cuối cùng của dòng đầu tiên trong văn bản cho trước:</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line(&quot;Hello, world\nHow are you today?&quot;),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;\nhi&quot;), None);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-11: Sử dụng toán tử <code>?</code> trên một giá trị
<code>Option&lt;T&gt;</code></span></p>
<p>Hàm này trả về <code>Option&lt;char&gt;</code> vì có thể có một ký tự ở đó, nhưng cũng có thể
không có. Code này lấy đoạn chuỗi <code>text</code> và gọi phương thức <code>lines</code> trên nó,
nó sẽ trả về một iterator (vòng lặp) trên các dòng trong chuỗi. Vì hàm này muốn
xem xét dòng đầu tiên, nó gọi <code>next</code> trên iterator để lấy giá trị đầu tiên từ
iterator. Nếu <code>text</code> là một chuỗi rỗng, cuộc gọi <code>next</code> này sẽ trả về <code>None</code>,
trong trường hợp này chúng ta sử dụng <code>?</code> để dừng và trả về <code>None</code> từ
<code>last_char_of_first_line</code>. Nếu <code>text</code> không phải là một chuỗi rỗng, <code>next</code> sẽ
trả về một giá trị <code>Some</code> chứa một đoạn chuỗi của dòng đầu tiên trong <code>text</code>.</p>
<p><code>?</code> trích xuất đoạn chuỗi, và chúng ta có thể gọi <code>chars</code> trên đoạn chuỗi đó để
lấy một iterator (vòng lặp) của các ký tự trong đoạn chuỗi. Chúng ta quan tâm
đến ký tự cuối cùng trong dòng đầu tiên này, vì vậy chúng ta gọi <code>last</code> để
trả về item cuối cùng trong iterator. Đây là một <code>Option</code> vì có thể dòng đầu
tiên là một chuỗi rỗng, ví dụ nếu <code>text</code> bắt đầu với một dòng trắng nhưng có
các ký tự trên các dòng khác, như trong <code>&quot;\nhi&quot;</code>. Tuy nhiên, nếu có một ký tự
cuối cùng trên dòng đầu tiên, nó sẽ được trả về trong biến <code>Some</code>. Toán tử <code>?</code>
ở giữa cung cấp cho chúng ta một cách ngắn gọn để biểu thị logic này, cho phép
chúng ta thực hiện hàm trong một dòng. Nếu chúng ta không thể sử dụng toán tử
<code>?</code> trên <code>Option</code>, chúng ta sẽ phải thực hiện logic này bằng cách sử dụng nhiều
phương thức gọi hơn hoặc một biểu thức <code>match</code>.</p>
<p>Lưu ý rằng bạn có thể sử dụng toán tử <code>?</code> trên một <code>Result</code> trong một hàm trả
về <code>Result</code>, và bạn có thể sử dụng toán tử <code>?</code> trên một <code>Option</code> trong một hàm
trả về <code>Option</code>, nhưng bạn không thể kết hợp và phối hợp. Toán tử <code>?</code> sẽ không
tự động chuyển đổi một <code>Result</code> thành một <code>Option</code> hoặc ngược lại; trong những
trường hợp đó, bạn có thể sử dụng các phương thức như phương thức <code>ok</code> trên
<code>Result</code> hoặc phương thức <code>ok_or</code> trên <code>Option</code> để thực hiện chuyển đổi một cách
rõ ràng.</p>
<p>Hiện tại, tất cả các hàm <code>main</code> mà chúng ta đã sử dụng trả về <code>()</code>. Hàm <code>main</code>
đặc biệt bởi vì nó là điểm vào (entry point) và ra của các chương trình thực
thi, và có những hạn chế về kiểu trả về của nó để các chương trình hoạt động
như mong đợi.</p>
<p>May mắn thay, <code>main</code> cũng có thể trả về một <code>Result&lt;(), E&gt;</code>. Listing 9-12 có
code từ Listing 9-10 nhưng đã thay đổi kiểu trả về của <code>main</code> thành
<code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> và thêm một giá trị trả về <code>Ok(())</code> vào cuối.
Code này sẽ bây giờ được biên dịch:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}</code></pre>
<p><span class="caption">Listing 9-12: Đổi <code>main</code> để trả về <code>Result&lt;(), E&gt;</code> cho
phép sử dụng toán tử <code>?</code> trên các giá trị <code>Result</code></span></p>
<p>Kiểu <code>Box&lt;dyn Error&gt;</code> là một <em>trait object</em>, mà chúng ta sẽ nói về nó trong
phần <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects that Allow for Values of Different
Types”</a><!-- ignore --> trong Chương 17. Hiện tại, bạn có thể
đọc <code>Box&lt;dyn Error&gt;</code> là “bất kỳ loại lỗi nào”. Sử dụng <code>?</code> trên một giá trị
<code>Result</code> trong một hàm <code>main</code> với kiểu lỗi <code>Box&lt;dyn Error&gt;</code> được cho phép,
bởi vì nó cho phép bất kỳ giá trị <code>Err</code> nào được trả về sớm. Dù cho phần thân
của hàm <code>main</code> này sẽ chỉ trả về lỗi của kiểu <code>std::io::Error</code>, bằng cách
xác định <code>Box&lt;dyn Error&gt;</code>, kiểu này sẽ tiếp tục đúng ngay cả khi thêm code
mà trả về các lỗi khác vào phần thân của <code>main</code>.</p>
<p>Khi hàm <code>main</code> trả về <code>Result&lt;(), E&gt;</code>, chương trình sẽ thoát với một giá
trị <code>0</code> nếu <code>main</code> trả về <code>Ok(())</code> và sẽ thoát với một giá trị khác không
phải <code>0</code> nếu <code>main</code> trả về một giá trị <code>Err</code>. Các chương trình được viết bằng
C trả về các số nguyên khi thoát: các chương trình thoát thành công trả về
số nguyên <code>0</code>, và các chương trình bị lỗi trả về một số nguyên khác không
phải <code>0</code>. Rust cũng trả về các số nguyên từ các chương trình để tương thích
với quy ước này.</p>
<p>Hàm <code>main</code> có thể trả về bất kỳ kiểu nào thực thi <a href="../std/process/trait.Termination.html">the
<code>std::process::Termination</code> trait</a><!-- ignore -->, mà chứa một
hàm <code>report</code> trả về một <code>ExitCode</code>. Hãy xem tài liệu thư viện chuẩn để biết
thêm thông tin về việc thực thi trait <code>Termination</code> cho các kiểu của bạn.</p>
<p>Bây giờ chúng ta đã thảo luận về chi tiết về việc gọi <code>panic!</code> hoặc trả về
<code>Result</code>, hãy trở lại về chủ đề làm thế nào để quyết định sử dụng cái nào
trong các trường hợp cụ thể.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
