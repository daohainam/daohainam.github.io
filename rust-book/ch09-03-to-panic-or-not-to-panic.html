<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>To panic! or Not to panic! - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Ngôn ngữ lập trình Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Cài đặt</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html" class="active"><strong aria-hidden="true">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="to-panic-or-not-to-panic"><a class="header" href="#to-panic-or-not-to-panic">To <code>panic!</code> or Not to <code>panic!</code></a></h2>
<p>Khi nào bạn nên dùng <code>panic</code> và khi nào nên return về <code>Result</code>? Khi code panic,
thì không có cách nào để khôi phục lại. Bạn có thể dùng <code>panic</code> cho bất kỳ
trường hợp lỗi nào, dù có thể khôi phục lại hay không, nhưng bạn sẽ phải đưa ra
quyết định rằng một trường hợp là không thể khôi phục lại được, đối với code gọi
hàm. Khi bạn chọn trả về một giá trị <code>Result</code>, bạn sẽ cho phép code gọi hàm có
các lựa chọn. Code gọi hàm có thể chọn cách khôi phục lại một cách phù hợp với
trường hợp của nó, hoặc nó có thể quyết định rằng một giá trị <code>Err</code> trong trường
hợp này là không thể khôi phục lại được, vì vậy nó có thể gọi <code>panic</code> và chuyển
một lỗi có thể khôi phục lại thành một lỗi không thể khôi phục lại. Do đó, trả
về một giá trị <code>Result</code> là một lựa chọn mặc định tốt khi bạn định nghĩa một hàm
có thể gây lỗi.</p>
<p>Trong các trường hợp như ví dụ, code prototype, và các test code, thì viết code
dùng <code>panic</code> thay vì trả về một giá trị <code>Result</code> là phù hợp hơn. Chúng ta sẽ tìm
hiểu tại sao như vậy, sau đó thảo luận về các trường hợp mà compiler không thể
biết được rằng việc gây lỗi là không thể, nhưng bạn là một con người có thể.
Chương này sẽ kết thúc với một số hướng dẫn chung về cách quyết định có nên dùng
<code>panic</code> trong code của thư viện hay không.</p>
<h3 id="examples-prototype-code-and-tests"><a class="header" href="#examples-prototype-code-and-tests">Examples, Prototype Code, and Tests</a></h3>
<p>Khi bạn viết một ví dụ để minh hoạ một khái niệm nào đó, việc bao gồm code xử lý
lỗi kỹ lưỡng cũng có thể làm cho ví dụ kém rõ ràng hơn. Trong một ví dụ,
dễ hiểu rằng gọi đến một phương thức như <code>unwrap</code> có thể gây lỗi
panic giống như là một bản thay thế cho cách bạn muốn ứng dụng của bạn xử lý
lỗi, mà có thể khác nhau với các phần khác trong code của bạn.</p>
<p>Tương tự, phương thức <code>unwrap</code> và <code>expect</code> rất hữu ích khi đang prototype,
trước khi bạn đã sẵn sàng để quyết định cách xử lý lỗi. Chúng để lại các dấu
chỉ rõ ràng trong code của bạn khi bạn đã sẵn sàng để làm cho chương trình
của bạn mạnh cứng cáp hơn.</p>
<p>Nếu một phương thức gọi thất bại trong một test, bạn sẽ muốn toàn bộ test thất
bại, ngay cả khi phương thức đó không phải là chức năng đang được test. Bởi
vì <code>panic!</code> là cách để một test được đánh dấu là thất bại, việc gọi <code>unwrap</code>
hoặc <code>expect</code> chính là những gì nên xảy ra.</p>
<h3 id="cases-in-which-you-have-more-information-than-the-compiler"><a class="header" href="#cases-in-which-you-have-more-information-than-the-compiler">Cases in Which You Have More Information Than the Compiler</a></h3>
<p>Sẽ là chấp nhận được nếu bạn gọi <code>unwrap</code> hoặc <code>expect</code> khi bạn có một logic
khác mà đảm bảo <code>Result</code> sẽ có một giá trị <code>Ok</code>, nhưng logic này không phải là
một thứ mà compiler hiểu được. Bạn vẫn sẽ có một giá trị <code>Result</code> mà bạn cần
phải xử lý: bất kỳ hoạt động nào bạn đang gọi vẫn có thể thất bại, ngay cả
khi nó là vô lý trong trường hợp cụ thể của bạn. Nếu bạn có thể đảm bảo bằng
cách thủ công kiểm tra code mà bạn sẽ không bao giờ có một biến thể <code>Err</code>, thì
nó là hoàn toàn chấp nhận được để gọi <code>unwrap</code>, và còn tốt hơn là viết lý do
bạn nghĩ bạn sẽ không bao giờ có một biến thể <code>Err</code> trong văn bản <code>expect</code>.
Đây là một ví dụ:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;
        .parse()
        .expect(&quot;Hardcoded IP address should be valid&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Chúng ta đang tạo một instance <code>IpAddr</code> bằng cách truyền vào một chuỗi cố định
(hardcode). Chúng ta có thể thấy <code>127.0.0.1</code> là một địa chỉ IP hợp lệ, do đó
việc sử dụng <code>expect</code> ở đây là chấp nhận được. Tuy nhiên, việc có một chuỗi hợp
lệ cố định không thay đổi kiểu trả về của phương thức <code>parse</code>: chúng ta vẫn
nhận được một giá trị <code>Result</code>, và compiler vẫn sẽ yêu cầu chúng ta xử lý
<code>Result</code> như nó có thể có biến thể <code>Err</code> vì compiler không đủ thông minh để
nhìn thấy rằng chuỗi này luôn luôn là một địa chỉ IP hợp lệ. Nếu chuỗi địa chỉ
IP được lấy từ người dùng thay vì được cố định trong chương trình và do đó
<em>có thể</em> có một khả năng thất bại, chúng ta sẽ chắc chắn muốn xử lý <code>Result</code> một
cách linh hoạt hơn. Việc nhắc nhở rằng giả định này là địa chỉ IP được cố định
sẽ làm chúng ta thay đổi <code>expect</code> thành một cách xử lý lỗi tốt hơn nếu trong
tương lai, chúng ta cần lấy địa chỉ IP từ một nguồn khác thay vì địa chỉ IP cố
định.</p>
<h3 id="guidelines-for-error-handling"><a class="header" href="#guidelines-for-error-handling">Guidelines for Error Handling</a></h3>
<p>Sẽ tốt hơn nếu code của bạn gọi <code>panic!</code> khi có thể code của bạn sẽ gặp một
trạng thái không tốt. Trong ngữ cảnh này, một 
<em>trạng thái không tốt (bad state)</em> là khi một giả định (assumption),
bảo đảm (guarantee), hợp đồng (contract), hoặc bất biến (invariant) nào đó đã
bị phá vỡ, như khi các giá trị không hợp lệ, giá trị trái ngược, hoặc các giá
trị bị thiếu được truyền vào code của bạn - cộng với một hoặc nhiều trong những
điều sau:</p>
<ul>
<li>Trạng thái không tốt này là một điều không mong đợi, khác với điều có thể
xảy ra thường xuyên, như người dùng nhập dữ liệu sai định dạng.</li>
<li>Code của bạn sau điểm này cần phải chắc rằng nó không muốn trong trạng thái
không tốt này, thay vì kiểm tra vấn đề này ở mỗi bước.</li>
<li>Không có một cách nào để encode thông tin này trong các kiểu mà bạn sử dụng.
Chúng ta sẽ làm ví dụ về điều này trong phần <a href="ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">“Encoding States and Behavior
as Types”</a><!-- ignore --> của chương 17.</li>
</ul>
<p>Nếu ai đó gọi code của bạn và truyền vào các giá trị không có ý nghĩa, tốt nhất
là trả về một lỗi nếu bạn có thể để người dùng thư viện có thể quyết định họ
muốn làm gì trong trường hợp đó. Tuy nhiên, trong trường hợp tiếp tục có thể
không an toàn hoặc có hại, lựa chọn tốt nhất có thể là gọi <code>panic!</code> và thông
báo cho người sử dụng thư viện của bạn về lỗi trong code của họ để họ có thể
sửa chữa trong quá trình phát triển. Tương tự, <code>panic!</code> thường được sử dụng nếu
bạn đang gọi code bên ngoài mà bạn không kiểm soát được và nó trả về một trạng
thái không hợp lệ mà bạn không thể sửa được.</p>
<p>Tuy nhiên, khi thất bại là có thể dự đoán được, sẽ thích hợp hơn để trả về một
<code>Result</code> hơn là gọi một <code>panic!</code>. Ví dụ bao gồm một bộ phân tích được cung cấp
dữ liệu bị lỗi hoặc một yêu cầu HTTP trả về một trạng thái cho thấy bạn đã đạt
giới hạn tốc độ. Trong những trường hợp này, trả về một <code>Result</code> cho thấy thất
bại là một khả năng được dự đoán rằng code gọi phải quyết định cách xử lý.</p>
<p>Khi code của bạn thực hiện một hoạt động có thể  tạo ra rủi ro cho người dùng
nếu nó được gọi bằng cách sử dụng giá trị không hợp lệ, code của bạn nên kiểm
tra giá trị hợp lệ trước và gọi <code>panic!</code> nếu giá trị không hợp lệ. Điều này
chủ yếu là vì lý do an toàn: cố gắng thực hiện các hoạt động trên dữ liệu không
hợp lệ có thể tiếp cận code của bạn với các lỗ hổng bảo mật. Đây là lý do chính
tại sao thư viện chuẩn sẽ gọi <code>panic!</code> nếu bạn cố gắng truy cập bộ nhớ ngoài
phạm vi: cố gắng truy cập bộ nhớ không thuộc cấu trúc dữ liệu hiện tại là một
vấn đề bảo mật phổ biến. Các hàm thường có <em>hợp đồng (contract)</em>: hành vi của
chúng chỉ được đảm bảo nếu đầu vào đáp ứng các yêu cầu nhất định. Gọi <code>panic!</code>
khi vi phạm hợp đồng là hợp lý bởi vì vi phạm hợp đồng luôn luôn chỉ ra lỗi ở
phía gọi và nó không phải là một loại lỗi bạn muốn code gọi phải xử lý một cách
rõ ràng. Thực ra, không có cách nào cho code gọi phục hồi; người lập trình viên
gọi cần phải sửa code. Hợp đồng cho một hàm, đặc biệt là khi một vi phạm sẽ gây
ra <code>panic!</code>, nên được giải thích trong tài liệu API cho hàm đó.</p>
<p>Tuy nhiên, có nhiều kiểm tra lỗi trong tất cả các hàm của bạn sẽ rất dài dòng
và phiền phức. May mắn thay, bạn có thể sử dụng hệ thống kiểu của Rust (và vì
vậy là kiểm tra kiểu được thực hiện bởi trình biên dịch) để thực hiện nhiều
kiểm tra cho bạn. Nếu hàm của bạn có một kiểu cụ thể làm tham số, bạn có thể
tiếp tục với logic code của mình biết rằng trình biên dịch đã đảm bảo bạn có một
giá trị hợp lệ. Ví dụ, nếu bạn có một kiểu thay vì một <code>Option</code>, chương trình
của bạn mong đợi sẽ <em>có gì đó</em> thay vì <em>không có gì</em>. Code của bạn sau đó không
cần phải xử lý hai trường hợp cho các biến thể <code>Some</code> và <code>None</code>: nó sẽ chỉ có
một trường hợp cho việc chắc chắn có một giá trị. Code cố gắng truyền không có
gì cho hàm của bạn sẽ không thể biên dịch, vì vậy hàm của bạn không cần phải
kiểm tra trường hợp đó khi chạy. Một ví dụ khác là sử dụng một kiểu số nguyên
không dấu như <code>u32</code>, đảm bảo tham số không bao giờ âm.</p>
<h3 id="creating-custom-types-for-validation"><a class="header" href="#creating-custom-types-for-validation">Creating Custom Types for Validation</a></h3>
<p>Lấy ý tưởng sử dụng hệ thống kiểu Rust để đảm bảo chúng ta có một giá trị hợp
lệ, hơn nữa là tạo một kiểu tùy chỉnh cho việc xác thực. Nhớ lại trò chơi đoán
số trong Chương 2 trong đó code của chúng ta yêu cầu người dùng đoán một số
giữa 1 và 100. Chúng ta không bao giờ xác thực rằng đoán của người dùng nằm
giữa hai số này trước khi kiểm tra nó với số bí mật của chúng ta; chúng ta chỉ
xác thực rằng đoán là dương. Trong trường hợp này, hậu quả không quá nghiêm
trọng: output của chúng ta có thể &quot;Quá cao&quot; hoặc &quot;Quá thấp&quot; vẫn sẽ chính xác. Nhưng nó sẽ là một sự cải thiện có ích để hướng dẫn người dùng đến các đoán hợp
lệ và có hành vi khác nhau khi người dùng đoán một số nằm ngoài phạm vi so với
khi người dùng nhập, ví dụ, các chữ cái thay vì số.</p>
<p>Một cách để làm điều này là phân tích đoán dưới dạng <code>i32</code> thay vì chỉ <code>u32</code> để
cho phép các số âm, và sau đó thêm một kiểm tra cho số nằm trong phạm vi, như
sau:</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;The secret number will be between 1 and 100.&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
<p>Dòng <code>if</code> kiểm tra xem giá trị của chúng ta có nằm ngoài phạm vi hay không, nói
với người dùng về vấn đề này, và gọi <code>continue</code> để bắt đầu vòng lặp tiếp theo
và yêu cầu một đoán khác. Sau dòng <code>if</code>, chúng ta có thể tiếp tục với các
sự so sánh giữa <code>guess</code> và số bí mật biết rằng <code>guess</code> nằm giữa 1 và 100.</p>
<p>Tuy nhiên, đây không phải là một giải pháp tối ưu: nếu nó là rất quan trọng
cho chương trình chỉ hoạt động trên các giá trị giữa 1 và 100, và nó có nhiều
hàm với yêu cầu này, có một kiểm tra như thế này trong mỗi hàm sẽ là một việc
nhàm chán (và có thể ảnh hưởng đến hiệu suất (performance)).</p>
<p>Thay vào đó, chúng ta có thể tạo một kiểu mới và đặt các xác thực trong một
hàm để tạo một thể hiện của kiểu thay vì lặp lại các xác thực ở mọi nơi. Đó
làm cho an toàn cho các hàm sử dụng kiểu mới trong chữ ký của chúng và tin tưởng
vào các giá trị mà chúng nhận được. Listing 9-13 cho thấy một cách để định nghĩa
một kiểu <code>Guess</code> sẽ chỉ tạo một thể hiện của <code>Guess</code> nếu hàm <code>new</code> nhận được một
giá trị giữa 1 và 100.</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-13: Một kiểu <code>Guess</code> sẽ chỉ tiếp tục với các
giá trị giữa 1 và 100</span></p>
<p>Đầu tiên, chúng ta định nghĩa một struct có tên <code>Guess</code> có một trường có tên
<code>value</code> chứa một <code>i32</code>. Đây là nơi số sẽ được lưu trữ.</p>
<p>Sau đó chúng ta hiện thưc một hàm <code>new</code> trên <code>Guess</code> để tạo các instance
của <code>Guess</code>. Hàm <code>new</code> được định nghĩa để có một tham số có tên <code>value</code> của kiểu
<code>i32</code> và trả về một <code>Guess</code>. Code trong thân hàm <code>new</code> kiểm tra <code>value</code> để chắc
chắn nó nằm trong khoảng từ 1 đến 100. Nếu <code>value</code> không đạt được điều kiện này,
chúng ta sẽ gọi một <code>panic!</code>, đó sẽ thông báo cho người lập trình viên đang viết
code gọi hàm này rằng họ có một lỗi mà họ cần phải sửa, vì tạo một <code>Guess</code> với
<code>value</code> nằm ngoài phạm vi này sẽ vi phạm hợp đồng mà <code>Guess::new</code> đang phụ thuộc
vào. Các điều kiện mà <code>Guess::new</code> có thể gây ra <code>panic!</code> nên được thảo luận
trong tài liệu API của nó; chúng ta sẽ thảo luận về các quy ước về tài liệu
trong chương 14. Nếu <code>value</code> đạt được điều kiện này, chúng ta sẽ tạo một
<code>Guess</code> mới với trường <code>value</code> được thiết lập thành tham số <code>value</code> và trả về
<code>Guess</code>.</p>
<p>Tiếp theo, chúng ta hiện thực một phương thức có tên <code>value</code> mà mượn <code>self</code>,
không có bất kỳ tham số nào khác, và trả về một <code>i32</code>. Loại phương thức này
đôi khi được gọi là <em>getter</em>, vì mục đích của nó là để lấy một số dữ liệu từ
các trường của nó. Phương thức công khai này là cần thiết vì trường <code>value</code> của
<code>Guess</code> struct là riêng tư. Quan trọng là trường <code>value</code> phải là riêng tư để
code sử dụng <code>Guess</code> struct không được phép thiết lập <code>value</code> trực tiếp: code
bên ngoài module <em>phải</em> sử dụng hàm <code>Guess::new</code> để tạo một thể hiện của
<code>Guess</code>, vì vậy đảm bảo rằng không có cách nào cho một <code>Guess</code> có một <code>value</code>
mà chưa được kiểm tra bởi các điều kiện trong hàm <code>Guess::new</code>.</p>
<p>Một hàm có một tham số hoặc trả về chỉ các số từ 1 đến 100 có thể sau đó khai
báo trong chữ ký (signature) của nó rằng nó nhận hoặc trả về một <code>Guess</code> thay
vì một <code>i32</code> và không cần phải làm bất kỳ kiểm tra bổ sung nào trong thân hàm
của nó.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Xử lý lỗi trong Rust được thiết kế để giúp bạn viết mã có tính ổn định cao hơn.
<code>panic!</code> macro cho biết rằng chương trình của bạn đang ở một trạng thái nó không
thể xử lý và cho phép bạn nói với quá trình dừng thay vì cố gắng tiếp tục với
giá trị không hợp lệ hoặc không chính xác. <code>Result</code> enum sử dụng hệ thống kiểu
của Rust để chỉ ra rằng các hoạt động có thể thất bại một cách mà mã của bạn có
thể khôi phục được. Bạn có thể sử dụng <code>Result</code> để nói với mã gọi mã của bạn
rằng nó cần phải xử lý thành công hoặc thất bại có thể xảy ra. Sử dụng <code>panic!</code>
và <code>Result</code> trong các tình huống phù hợp sẽ làm mã của bạn ổn định hơn đối với
các vấn đề không thể tránh được.</p>
<p>Bây giờ bạn đã thấy các cách sử dụng hữu ích mà thư viện chuẩn sử dụng với
<code>Option</code> và <code>Result</code> enum, chúng ta sẽ nói về cách hoạt động của generics và
cách bạn có thể sử dụng chúng trong mã của bạn.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-00-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-00-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
