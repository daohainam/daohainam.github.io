<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Paths for Referring to an Item in the Module Tree - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Ngôn ngữ lập trình Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Lời nói đầu</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Giới thiệu</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Bắt đầu</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Cài đặt</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Lập trình trò chơi đoán số</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Các khái niệm chung trong lập trình</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Biến và tính khả biến</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Các kiểu dữ liệu</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Hàm</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Ghi chú</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Các khối điều khiển</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Tìm hiểu về Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Ownership là gì?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Tham chiếu (reference) và mượn (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Kiểu Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Sử dụng Structs để kết hợp các dữ liệu có liên quan</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Định nghĩa và khởi tạo Struct</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Một ví dụ về lập trình với Struct</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Cú pháp phương thức</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Kiểu Enum và khớp mẫu</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Định nghĩa một Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Cấu trúc điều khiển match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Điều khiển luồng thực thi một các chính xác với if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="active"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="paths-for-referring-to-an-item-in-the-module-tree"><a class="header" href="#paths-for-referring-to-an-item-in-the-module-tree">Paths for Referring to an Item in the Module Tree</a></h2>
<p>Để chỉ cho Rust biết nơi tìm thấy một item trong cây module, chúng ta sử dụng
một đường dẫn (path) tương tự như chúng ta sử dụng một đường dẫn trong một hệ
thống tập tin. Để gọi một hàm, chúng ta cần biết đường dẫn của nó.</p>
<p>Một đường dẫn có thể có hai dạng:</p>
<ul>
<li><em>Đường dẫn tuyệt đối (absolute path)</em> là đường dẫn đầy đủ bắt đầu từ một
crate root; đối với code từ một crate bên ngoài, đường dẫn tuyệt đối bắt đầu với
tên crate, và đối với code từ crate hiện tại, nó bắt đầu với từ khoá <code>crate</code>.</li>
<li><em>Đường dẫn tương đối (relative path)</em> bắt đầu từ module hiện tại và sử dụng
<code>self</code>, <code>super</code>, hoặc một định danh (identifier) trong module hiện tại.</li>
</ul>
<p>Cả đường dẫn tuyệt đối và tương đối đều được theo sau bởi một hoặc nhiều định
danh (identifier) được phân tách bởi hai dấu hai chấm (<code>::</code>).</p>
<p>Trở lại Listing 7-1, giả sử chúng ta muốn gọi hàm <code>add_to_waitlist</code>. Điều này
tương đương với câu hỏi: đường dẫn của hàm <code>add_to_waitlist</code> là gì? Listing 7-3
chứa Listing 7-1 với một số module và hàm bị xóa. Chúng ta sẽ hiển thị hai cách
gọi hàm <code>add_to_waitlist</code> từ một hàm mới <code>eat_at_restaurant</code> được định nghĩa
trong crate root. Hàm <code>eat_at_restaurant</code> là một phần của API công khai của
library crate của chúng ta, vì vậy chúng ta đánh dấu nó với từ khoá <code>pub</code>.
Trong phần <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">“Exposing Paths with the <code>pub</code> Keyword”</a><!-- ignore -->, chúng
ta sẽ đi sâu vào chi tiết hơn về <code>pub</code>. Lưu ý rằng ví dụ này tạm thời sẽ không
được biên dịch; chúng ta sẽ giải thích tại trong ít phút nữa.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listing 7-3: Gọi hàm <code>add_to_waitlist</code> sử dụng đường dẫn
tuyệt đối và tương đối</span></p>
<p>Lần đầu tiên chúng ta gọi hàm <code>add_to_waitlist</code> trong <code>eat_at_restaurant</code>, chúng
ta sử dụng đường dẫn tuyệt đối. Hàm <code>add_to_waitlist</code> được định nghĩa trong cùng
một crate với <code>eat_at_restaurant</code>, điều này có nghĩa là chúng ta có thể sử dụng
từ khoá <code>crate</code> để bắt đầu một đường dẫn tuyệt đối. Sau đó, chúng ta sẽ đi qua
từng tên của các module cho đến khi chúng ta bắt gặp <code>add_to_waitlist</code>.
Bạn có thể tưởng tượng một hệ thống tệp tin với cùng cấu trúc: chúng ta sẽ chỉ
định đường dẫn <code>/front_of_house/hosting/add_to_waitlist</code> để chạy chương trình
<code>add_to_waitlist</code>; sử dụng từ khoá <code>crate</code> để bắt đầu từ crate root giống như
sử dụng <code>/</code> để bắt đầu từ thư mục gốc của hệ thống tệp tin trong shell của bạn.</p>
<p>Lần thứ hai chúng ta gọi <code>add_to_waitlist</code> trong <code>eat_at_restaurant</code>, chúng ta
sử dụng đường dẫn tương đối. Đường dẫn bắt đầu với <code>front_of_house</code>, tên của
module được định nghĩa cùng cấp với module tree của <code>eat_at_restaurant</code>. Ở đây
đường dẫn tương đương với hệ thống tệp tin sẽ là sử dụng đường dẫn
<code>front_of_house/hosting/add_to_waitlist</code>. Bắt đầu với tên của module có nghĩa
rằng đường dẫn là tương đối.</p>
<p>Việc lựa chọn sử dụng đường dẫn tương đối hay tuyệt đối là một quyết định bạn
sẽ đưa ra dựa trên dự án, và phụ thuộc vào việc bạn có thể di chuyển
định nghĩa code của item riêng biệt hay cùng với code sử dụng item. Ví dụ, nếu
chúng ta di chuyển module <code>front_of_house</code> và hàm <code>eat_at_restaurant</code> vào một
module có tên <code>customer_experience</code>, chúng ta sẽ cần cập nhật đường dẫn tuyệt
đối đến <code>add_to_waitlist</code>, nhưng đường dẫn tương đối vẫn là hợp lệ. Tuy nhiên,
nếu chúng ta di chuyển hàm <code>eat_at_restaurant</code> riêng biệt vào một module có tên
<code>dining</code>, đường dẫn tuyệt đối đến <code>add_to_waitlist</code> vẫn giữ nguyên, nhưng đường
dẫn tương đối sẽ cần được cập nhật. Nhìn chung, chúng tôi thích dùng đường dẫn
tuyệt đối vì nó có thể  giúp chúng tôi di chuyển code định nghĩa và code gọi
item độc lập với nhau.</p>
<p>Hãy thử biên dịch Listing 7-3 và tìm hiểu tại sao nó vẫn chưa biên dịch được!
Lỗi mà chúng ta nhận được được hiển thị trong Listing 7-4.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Listing 7-4: Lỗi biên dịch từ việc biên dịch code trong
Listing 7-3</span></p>
<p>Các thông báo lỗi nói rằng module <code>hosting</code> là riêng tư. Nói cách khác, chúng
ta có đúng đường dẫn cho module <code>hosting</code> và hàm <code>add_to_waitlist</code>, nhưng Rust
không cho phép chúng ta sử dụng chúng vì nó không có quyền truy cập vào các
phần riêng tư. Trong Rust, tất cả các item (hàm, phương thức, struct, enum,
module, và hằng số) là private đối với module cha theo mặc định. Nếu bạn muốn
tạo một item như một hàm hoặc struct private, bạn cần đặt nó trong một module.</p>
<p>Các item trong module cha không thể sử dụng các item private bên trong module
con, nhưng các item trong module con có thể sử dụng các item trong các module
cha của nó. Điều này là vì module đã gói các chi tiết code của nó và ẩn chúng đi
nhưng module con có thể thấy được ngữ cảnh mà nó được định nghĩa. Để tiếp tục
với ví dụ của chúng ta, hãy nghĩ về quy tắc riêng tư như là một phòng họp của
một nhà hàng: những gì xảy ra bên trong phòng họp là riêng tư đối với khách hàng
(tức là họ, khách hàng, không thể truy cập vào phòng họp), nhưng quản lý nhà
hàng có thể thấy và làm mọi thứ trong nhà hàng mà họ quản lý.</p>
<p>Rust đã chọn để hệ thống module hoạt động theo cách này để ẩn các chi tiết
code bên trong một cách mặc định. Theo cách này, bạn biết được những phần của
code bên trong mà bạn có thể thay đổi mà không làm hỏng code bên ngoài. Tuy
nhiên, Rust cũng cho phép bạn lựa chọn để tiết lộ các phần bên trong của module
con đến các module cha bên ngoài bằng cách sử dụng từ khóa <code>pub</code> để tạo một
item public.</p>
<h3 id="exposing-paths-with-the-pub-keyword"><a class="header" href="#exposing-paths-with-the-pub-keyword">Exposing Paths with the <code>pub</code> Keyword</a></h3>
<p>Cùng trở lại lỗi trong Listing 7-4 mà nói cho chúng ta rằng module <code>hosting</code>
là private. Chúng ta muốn hàm <code>eat_at_restaurant</code> trong module cha có thể
truy cập vào hàm <code>add_to_waitlist</code> trong module con, vì vậy chúng ta đánh dấu
module <code>hosting</code> với từ khóa <code>pub</code>, như trong Listing 7-5.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listing 7-5: Đánh dấu module <code>hosting</code> là <code>pub</code> để sử
dụng nó từ <code>eat_at_restaurant</code></span></p>
<p>Rất tiếc, code trong Listing 7-5 vẫn dẫn đến lỗi, như trong Listing 7-6.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Listing 7-6: Lỗi của compiler khi build code trong
Listing 7-5</span></p>
<p>Điều gì đã xảy ra? Việc thêm từ khóa <code>pub</code> trước <code>mod hosting</code> làm cho module
public. Với thay đổi này, nếu chúng ta có thể truy cập <code>front_of_house</code>, chúng
ta có thể truy cập <code>hosting</code>. Nhưng <em>nội dung</em> của <code>hosting</code> vẫn là private;
việc làm module public không làm cho nội dung của nó public. Từ khóa <code>pub</code> trên
module chỉ cho phép code ở module cha tham chiếu đến nó, không cho phép
truy cập code bên trong. Vì module là container, việc làm cho module public;
không thực sự giúp chúng ta việc gì, chúng ta cần đi xa hơn và chọn để làm
public một hoặc nhiều item bên trong module.</p>
<p>Lỗi trong Listing 7-6 nói rằng hàm <code>add_to_waitlist</code> là private. Quy tắc
privacy áp dụng cho struct, enum, function, và method cũng như module.</p>
<p>Hãy cũng làm cho hàm <code>add_to_waitlist</code> public bằng cách thêm từ khóa <code>pub</code>
trước định nghĩa của nó, như trong Listing 7-7.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listing 7-7: Thêm từ khóa <code>pub</code> vào <code>mod hosting</code> và
<code>fn add_to_waitlist</code> để chúng ta gọi hàm từ <code>eat_at_restaurant</code></span></p>
<p>Bây giờ code sẽ compile! Để biết tại sao thêm từ khóa <code>pub</code> cho phép chúng ta
sử dụng những đường dẫn này trong <code>add_to_waitlist</code> với quy tắc privacy, hãy
xem đường dẫn tuyệt đối và đường dẫn tương đối.</p>
<p>Trong đường dẫn tuyệt đối, chúng ta bắt đầu với <code>crate</code>, gốc của cây module
của crate. Module <code>front_of_house</code> được định nghĩa trong crate root. Khi
<code>front_of_house</code> không phải là public, vì hàm <code>eat_at_restaurant</code> được định
nghĩa trong cùng một module với <code>front_of_house</code> (tức là <code>eat_at_restaurant</code>
và <code>front_of_house</code> là anh em), chúng ta có thể tham chiếu đến <code>front_of_house</code>
từ <code>eat_at_restaurant</code>. Tiếp theo là module <code>hosting</code> được đánh dấu với <code>pub</code>.
Chúng ta có thể truy cập module cha của <code>hosting</code>, vì vậy chúng ta có thể truy
cập <code>hosting</code>. Cuối cùng, hàm <code>add_to_waitlist</code> được đánh dấu với <code>pub</code> và chúng
ta có thể truy cập module cha của nó, vì vậy cuộc gọi hàm này hoạt động!</p>
<p>Trong đường dẫn tương đối, logic là giống như đường dẫn tuyệt đối ngoại trừ
bước đầu tiên: thay vì bắt đầu từ crate root, đường dẫn bắt đầu từ
<code>front_of_house</code>. Module <code>front_of_house</code> được định nghĩa trong cùng một module
với <code>eat_at_restaurant</code>, vì vậy đường dẫn tương đối bắt đầu từ module mà
<code>eat_at_restaurant</code> được định nghĩa hoạt động. Sau đó, vì <code>hosting</code> và
<code>add_to_waitlist</code> được đánh dấu với <code>pub</code>, phần còn lại của đường dẫn hoạt
động, và cuộc gọi hàm này là hợp lệ!</p>
<p>Nếu bạn dự định chia sẻ library crate để các dự án khác có thể sử dụng mã của
bạn, API công khai của bạn là interface mà người dùng của crate của bạn tương
tác với mã của bạn. Có nhiều điều cần xem xét về việc quản lý các thay đổi
trong API công khai của bạn để làm cho việc phụ thuộc vào crate của bạn dễ dàng
hơn. Những điều này nằm ngoài phạm vi của cuốn sách này; nếu bạn quan tâm đến
chủ đề này, hãy xem <a href="https://rust-lang.github.io/api-guidelines/">The Rust API Guidelines</a>.</p>
<blockquote>
<h4 id="best-practices-for-packages-with-a-binary-and-a-library"><a class="header" href="#best-practices-for-packages-with-a-binary-and-a-library">Best Practices for Packages with a Binary and a Library</a></h4>
<p>Chúng ta đã nói rằng một package có thể chứa cả <em>src/main.rs</em> binary crate
root cũng như <em>src/lib.rs</em> library crate root, và cả hai crate sẽ có tên
package mặc định. Thông thường, các package dạng này sẽ chứa đủ code trong
binary crate để khởi động một chương trình thực thi, code này sẽ gọi đến
code tron library crate. Điều này cho phép các dự án khác có thể tận dụng
tối đa các chức năng mà package cung cấp, vì code trong library crate có thể
được chia sẻ.</p>
<p>Cây module nên được định nghĩa trong <em>src/lib.rs</em>. Sau đó, bất kỳ item công
khai nào cũng có thể được sử dụng trong binary crate bằng cách bắt đầu đường
dẫn với tên của package. Binary crate trở thành một người dùng của library
crate giống như một crate hoàn toàn bên ngoài sẽ sử dụng library crate: nó
chỉ có thể sử dụng API công khai. Điều này giúp bạn thiết kế một API tốt;
không chỉ là bạn là người viết, bạn cũng là người dùng!</p>
<p>Trong <a href="ch12-00-an-io-project.html">Chapter 12</a><!-- ignore -->, chúng ta sẽ minh họa cách tổ chức
này với một chương trình CLI sẽ chứa cả binary crate và library crate.</p>
</blockquote>
<hr />
<h3 id="starting-relative-paths-with-super"><a class="header" href="#starting-relative-paths-with-super">Starting Relative Paths with <code>super</code></a></h3>
<p>Chúng ta có thể khai báo đường dẫn tương đối bắt đầu từ module cha, thay vì
module hiện tại hoặc module gốc, bằng cách sử dụng <code>super</code> ở đầu đường dẫn.
Điều này giống như bắt đầu một đường dẫn hệ thống tập tin với cú pháp <code>..</code>.
Điều này cho phép chúng ta tham chiếu đến một item mà chúng ta biết nằm trong
module cha, điều này sẽ giúp chúng ta dễ dàng sắp xếp lại cây module khi module
đó liên quan gần với module cha, nhưng module cha có thể được di chuyển đến
một nơi khác trong cây module một lúc nào đó trong tương lai.</p>
<p>Xem code trong Listing 7-8 mô hình hóa tình huống trong đó một nhà bếp sửa
lỗi đơn hàng và mang đến cho khách hàng cá nhân. Hàm <code>fix_incorrect_order</code>
được định nghĩa trong module <code>back_of_house</code> gọi hàm <code>deliver_order</code> được định
nghĩa trong module cha bằng cách chỉ định đường dẫn đến <code>deliver_order</code> bắt đầu
bằng <code>super</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<p><span class="caption">Listing 7-8: Gọi một hàm sử dụng đường dẫn tương đối
bắt đầu bằng <code>super</code></span></p>
<p>Hàm <code>fix_incorrect_order</code> nằm trong module <code>back_of_house</code>, vì vậy chúng ta
có thể sử dụng <code>super</code> để đi đến module cha của <code>back_of_house</code>, trong trường
hợp này là <code>crate</code>, gốc. Từ đó, chúng ta tìm kiếm <code>deliver_order</code> và tìm thấy
nó. Chúng ta cho rằng module <code>back_of_house</code> và hàm <code>deliver_order</code>
có thể ở trong mối quan hệ tương tự và được di chuyển cùng nhau dù
chúng ta quyết định tổ chức lại cây module của crate. Do đó, chúng ta đã sử
dụng <code>super</code> để chúng ta sẽ có ít chỗ cần cập nhật code trong tương lai nếu code
này được di chuyển đến một module khác.</p>
<hr />
<h3 id="making-structs-and-enums-public"><a class="header" href="#making-structs-and-enums-public">Making Structs and Enums Public</a></h3>
<p>Chúng ta cũng có thể sử dụng <code>pub</code> để đánh dấu struct và enum là public, nhưng
có một số chi tiết khác về cách sử dụng <code>pub</code> với struct và enum. Nếu chúng ta
sử dụng <code>pub</code> trước một định nghĩa struct, chúng ta sẽ làm public struct, nhưng
các trường của struct vẫn sẽ là private. Chúng ta có thể làm public hoặc không
cho mỗi trường một cách riêng biệt. Trong Listing 7-9, chúng ta đã định nghĩa
một struct <code>back_of_house::Breakfast</code> public với một trường <code>toast</code> public
nhưng một trường <code>seasonal_fruit</code> private. Điều này mô hình trường hợp trong
một nhà hàng nơi khách hàng có thể chọn loại bánh mì mà họ muốn kèm theo một
bữa ăn, nhưng bếp trưởng quyết định loại quả tươi sẽ đi kèm theo bữa ăn dựa
trên mùa và hàng tồn kho. Các loại quả tươi thay đổi nhanh chóng, vì vậy khách
hàng không thể chọn loại quả tươi hoặc thậm chí xem được loại quả tươi mà họ sẽ
nhận được.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Change our mind about what bread we'd like
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}</code></pre>
<p><span class="caption">Listing 7-9: Một struct với một số trường public và một
số trường private</span></p>
<p>Bởi vì trường <code>toast</code> trong struct <code>back_of_house::Breakfast</code> là public, trong
<code>eat_at_restaurant</code> chúng ta có thể viết và đọc trường <code>toast</code> sử dụng dấu chấm
. Lưu ý rằng chúng ta không thể sử dụng trường <code>seasonal_fruit</code> trong
<code>eat_at_restaurant</code> vì <code>seasonal_fruit</code> là private. Hãy thử bỏ comment dòng
sửa đổi giá trị trường <code>seasonal_fruit</code> để xem có lỗi gì xảy ra!</p>
<p>Ngoài ra, lưu ý rằng vì <code>back_of_house::Breakfast</code> có một trường private, struct
cần phải cung cấp một hàm liên quan public để tạo một instance của <code>Breakfast</code>
(chúng ta đã đặt tên là <code>summer</code>). Nếu <code>Breakfast</code> không có hàm như vậy, chúng
ta không thể tạo một instance của <code>Breakfast</code> trong <code>eat_at_restaurant</code> vì chúng
ta không thể thiết lập giá trị của trường private <code>seasonal_fruit</code> trong
<code>eat_at_restaurant</code>.</p>
<p>Trái ngược với struct, nếu chúng ta đặt một enum là public, tất cả các variant
của nó sẽ là public. Chúng ta chỉ cần đặt <code>pub</code> trước từ khóa <code>enum</code>, như trong
Listing 7-10.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
<p><span class="caption">Listing 7-10: Đánh dấu một enum là public sẽ làm cho tất
cả các variant của nó là public</span></p>
<p>Bởi vì chúng ta đã đánh dấu enum <code>Appetizer</code> là public, chúng ta có thể sử dụng
variant <code>Soup</code> và <code>Salad</code> trong <code>eat_at_restaurant</code>.</p>
<p>Enum không có ích gì nếu các variant của nó không phải là public; sẽ rất phiền
phức phải đánh dấu tất cả các variant của enum với <code>pub</code> trong mọi trường hợp,
vì vậy mặc định cho variant của enum là public. Struct thường có ích mà không
cần các trường của nó là public, vì vậy các trường của struct theo quy tắc chung
của mọi thứ là private trừ khi được đánh dấu với <code>pub</code>.</p>
<p>Có một trường hợp nữa liên quan đến <code>pub</code> mà chúng ta chưa bàn đến, đó là tính
năng cuối cùng của module system: từ khóa <code>use</code>. Chúng ta sẽ bàn <code>use</code> một mình
trước, và sau đó chúng ta sẽ hiển thị cách kết hợp <code>pub</code> và <code>use</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
